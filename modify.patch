diff --git a/lalinspiral/python/lalinspiral/sbank/tau0tau3.py b/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
index 4cd3ebf00a..0127643c22 100644
--- a/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
+++ b/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
@@ -242,7 +242,7 @@ def tau0tau3_bound(flow, **constraints):
     # FIXME: As this is discrete, this can cause the bank sizes to be smaller
     # than expected. Raising this to 1e5, raising it higher starts to cause
     # slowdown as computing m2 from m1 and mchirp is expensive.
-    npts = 1e4
+    npts = int(1e4)
 
     # draw constant component mass lines
     m1min, m1max = constraints['mass1']
diff --git a/lalsimulation/lib/LALSimIMR.h b/lalsimulation/lib/LALSimIMR.h
index 0681a16136..b92f3c9696 100644
--- a/lalsimulation/lib/LALSimIMR.h
+++ b/lalsimulation/lib/LALSimIMR.h
@@ -149,6 +149,8 @@ int XLALSimIMRPhenomDFrequencySequence(COMPLEX16FrequencySeries **htilde, const
 double XLALIMRPhenomDGetPeakFreq(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in);
 double XLALSimIMRPhenomDChirpTime(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in, const REAL8 fHz);
 double XLALSimIMRPhenomDFinalSpin(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in);
+int XLALSimIMRPhenomDGenerateFDAmpPhs(COMPLEX16FrequencySeries **amplitude, COMPLEX16FrequencySeries **phase, const REAL8 phi0, const REAL8 fRef, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 chi1, const REAL8 chi2, const REAL8 f_min, const REAL8 f_max, const REAL8 distance, LALDict *extraParams, NRTidal_version_type NRTidal_version);
+
 
 int XLALSimIMRPhenomP(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 deltaF, const REAL8 f_min, const REAL8 f_max, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version, NRTidal_version_type NRTidal_version, LALDict *extraParams);
 int XLALSimIMRPhenomPFrequencySequence(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version, NRTidal_version_type NRTidal_version, LALDict *extraParams);
@@ -360,6 +362,7 @@ int XLALSimIMRLackeyTidal2013FrequencySequence(struct tagCOMPLEX16FrequencySerie
 /* in module LALSimIMRSEOBNRv4ROM.c */
 
 int XLALSimIMRSEOBNRv4ROM(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
+int XLALSimIMRSEOBNRv4ROMAmpPhs(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
 int XLALSimIMRSEOBNRv4ROMFrequencySequence(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, REAL8 phiRef, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
 int XLALSimIMRSEOBNRv4ROMTimeOfFrequency(REAL8 *t, REAL8 frequency, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
 int XLALSimIMRSEOBNRv4ROMFrequencyOfTime(REAL8 *frequency, REAL8 t, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
diff --git a/lalsimulation/lib/LALSimIMRPhenomD.c b/lalsimulation/lib/LALSimIMRPhenomD.c
index 0e6afffb29..587941d716 100644
--- a/lalsimulation/lib/LALSimIMRPhenomD.c
+++ b/lalsimulation/lib/LALSimIMRPhenomD.c
@@ -1070,3 +1070,449 @@ UNUSED REAL8 IMRPhenomDPhase_OneFrequency(
                               &(pD.phi_prefactors), Rholm, Taulm);
   return phase;
 }
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**Private function to compute the IMRPhenomD amplitude and phase **/
+/** 10 February, 2022, Soumen Roy **/
+
+
+/* *********************************************************************************/
+/* The following private function generates IMRPhenomD frequency-domain Amplitude  */
+/* and phase given coefficients */
+/* *********************************************************************************/
+
+
+
+
+
+
+
+/*
+ * private function prototypes; all internal functions use solar masses.
+ *
+ */
+
+static int IMRPhenomDGenerateFDAmpPhs(
+    COMPLEX16FrequencySeries **amplitude, /**< [out] FD amplitude */
+    COMPLEX16FrequencySeries **phase,  /**< [out] FD phase */
+    const REAL8Sequence *freqs_in,     /**< Frequency points at which to evaluate the waveform (Hz) */
+    double deltaF,                     /**< If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+                                        * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+                                        * Then we will use deltaF = 0 to create the frequency series we return. */
+    const REAL8 phi0,                  /**< phase at fRef */
+    const REAL8 fRef,                  /**< reference frequency [Hz] */
+    const REAL8 m1_in,                 /**< mass of companion 1 [solar masses] */
+    const REAL8 m2_in,                 /**< mass of companion 2 [solar masses] */
+    const REAL8 chi1_in,               /**< aligned-spin of companion 1 */
+    const REAL8 chi2_in,               /**< aligned-spin of companion 2 */
+    const REAL8 distance,              /**< distance to source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+);
+
+/**
+ * @addtogroup LALSimIMRPhenom_c
+ * @{
+ *
+ * @name Routines for IMR Phenomenological Model "D"
+ * @{
+ *
+ * @author Michael Puerrer, Sebastian Khan, Frank Ohme
+ *
+ * @brief C code for IMRPhenomD phenomenological waveform model.
+ *
+ * This is an aligned-spin frequency domain model.
+ * See Husa et al \cite Husa:2015iqa, and Khan et al \cite Khan:2015jqa
+ * for details. Any studies that use this waveform model should include
+ * a reference to both of these papers.
+ *
+ * @note The model was calibrated to mass-ratios [1:1,1:4,1:8,1:18].
+ * * Along the mass-ratio 1:1 line it was calibrated to spins  [-0.95, +0.98].
+ * * Along the mass-ratio 1:4 line it was calibrated to spins  [-0.75, +0.75].
+ * * Along the mass-ratio 1:8 line it was calibrated to spins  [-0.85, +0.85].
+ * * Along the mass-ratio 1:18 line it was calibrated to spins [-0.8, +0.4].
+ * The calibration points will be given in forthcoming papers.
+ *
+ * @attention The model is usable outside this parameter range,
+ * and in tests to date gives sensible physical results,
+ * but conclusive statements on the physical fidelity of
+ * the model for these parameters await comparisons against further
+ * numerical-relativity simulations. For more information, see the review wiki
+ * under https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview
+ */
+
+
+/**
+ * Driver routine to compute the spin-aligned, inspiral-merger-ringdown
+ * phenomenological waveform IMRPhenomD in the frequency domain.
+ *
+ * Reference:
+ * - Waveform: Eq. 35 and 36 in arXiv:1508.07253
+ * - Coefficients: Eq. 31 and Table V in arXiv:1508.07253
+ *
+ *  All input parameters should be in SI units. Angles should be in radians.
+ *
+ * Compute waveform in LAL format for the IMRPhenomD model.
+ *
+ * Returns the plus and cross polarizations as a complex frequency series with
+ * equal spacing deltaF and contains zeros from zero frequency to the starting
+ * frequency fLow and zeros beyond the cutoff frequency in the ringdown.
+ */
+int XLALSimIMRPhenomDGenerateFDAmpPhs(
+    COMPLEX16FrequencySeries **amplitude, /**< [out] FD amplitude */
+    COMPLEX16FrequencySeries **phase,  /**< [out] FD phase */
+    const REAL8 phi0,                  /**< Orbital phase at fRef (rad) */
+    const REAL8 fRef_in,               /**< reference frequency (Hz) */
+    const REAL8 deltaF,                /**< Sampling frequency (Hz) */
+    const REAL8 m1_SI,                 /**< Mass of companion 1 (kg) */
+    const REAL8 m2_SI,                 /**< Mass of companion 2 (kg) */
+    const REAL8 chi1,                  /**< Aligned-spin parameter of companion 1 */
+    const REAL8 chi2,                  /**< Aligned-spin parameter of companion 2 */
+    const REAL8 f_min,                 /**< Starting GW frequency (Hz) */
+    const REAL8 f_max,                 /**< End frequency; 0 defaults to Mf = \ref f_CUT */
+    const REAL8 distance,               /**< Distance of source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< Version of NRTides; can be one of NRTidal versions or NoNRT_V for the BBH baseline */
+) {
+  /* external: SI; internal: solar masses */
+  const REAL8 m1 = m1_SI / LAL_MSUN_SI;
+  const REAL8 m2 = m2_SI / LAL_MSUN_SI;
+
+  /* check inputs for sanity */
+  XLAL_CHECK(0 != amplitude, XLAL_EFAULT, "amplitude is null");
+  if (*amplitude) XLAL_ERROR(XLAL_EFAULT);
+  XLAL_CHECK(0 != phase, XLAL_EFAULT, "phase is null");
+  if (*phase) XLAL_ERROR(XLAL_EFAULT);
+  if (fRef_in < 0) XLAL_ERROR(XLAL_EDOM, "fRef_in must be positive (or 0 for 'ignore')\n");
+  if (deltaF <= 0) XLAL_ERROR(XLAL_EDOM, "deltaF must be positive\n");
+  if (m1 <= 0) XLAL_ERROR(XLAL_EDOM, "m1 must be positive\n");
+  if (m2 <= 0) XLAL_ERROR(XLAL_EDOM, "m2 must be positive\n");
+  if (f_min <= 0) XLAL_ERROR(XLAL_EDOM, "f_min must be positive\n");
+  if (f_max < 0) XLAL_ERROR(XLAL_EDOM, "f_max must be greater than 0\n");
+  if (distance <= 0) XLAL_ERROR(XLAL_EDOM, "distance must be positive\n");
+
+  const REAL8 q = (m1 > m2) ? (m1 / m2) : (m2 / m1);
+
+  if (q > MAX_ALLOWED_MASS_RATIO)
+    XLAL_PRINT_WARNING("Warning: The model is not supported for high mass ratio, see MAX_ALLOWED_MASS_RATIO\n");
+
+  if (chi1 > 1.0 || chi1 < -1.0 || chi2 > 1.0 || chi2 < -1.0)
+    XLAL_ERROR(XLAL_EDOM, "Spins outside the range [-1,1] are not supported\n");
+
+  // if no reference frequency given, set it to the starting GW frequency
+  REAL8 fRef = (fRef_in == 0.0) ? f_min : fRef_in;
+
+  const REAL8 M_sec = (m1+m2) * LAL_MTSUN_SI; // Conversion factor Hz -> dimensionless frequency
+  const REAL8 fCut = f_CUT/M_sec; // convert Mf -> Hz
+  // Somewhat arbitrary end point for the waveform.
+  // Chosen so that the end of the waveform is well after the ringdown.
+  if (fCut <= f_min)
+    XLAL_ERROR(XLAL_EDOM, "(fCut = %g Hz) <= f_min = %g\n", fCut, f_min);
+
+    /* default f_max to Cut */
+  REAL8 f_max_prime = f_max;
+  f_max_prime = f_max ? f_max : fCut;
+  f_max_prime = (f_max_prime > fCut) ? fCut : f_max_prime;
+  if (f_max_prime <= f_min)
+    XLAL_ERROR(XLAL_EDOM, "f_max <= f_min\n");
+
+  // Use fLow, fHigh, deltaF to compute freqs sequence
+  // Instead of building a full sequency we only transfer the boundaries and let
+  // the internal core function do the rest (and properly take care of corner cases).
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = f_min;
+  freqs->data[1] = f_max_prime;
+  int status = IMRPhenomDGenerateFDAmpPhs(amplitude, phase, freqs, deltaF, phi0, fRef,
+                                    m1, m2, chi1, chi2,
+                                    distance, extraParams, NRTidal_version);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to generate IMRPhenomD waveform.");
+  XLALDestroyREAL8Sequence(freqs);
+
+  if (f_max_prime < f_max) {
+    // The user has requested a higher f_max than Mf=fCut.
+    // Resize the frequency series to fill with zeros beyond the cutoff frequency.
+      
+    size_t n = (*amplitude)->data->length;
+    size_t n_full = NextPow2(f_max / deltaF) + 1; // we actually want to have the length be a power of 2 + 1
+    *amplitude = XLALResizeCOMPLEX16FrequencySeries(*amplitude, 0, n_full);
+    *phase = XLALResizeCOMPLEX16FrequencySeries(*phase, 0, n_full);
+    XLAL_CHECK ( *amplitude, XLAL_ENOMEM, "Failed to resize waveform COMPLEX16FrequencySeries of length %zu (for internal fCut=%f) to new length %zu (for user-requested f_max=%f).", n, fCut, n_full, f_max );
+  }
+
+  return XLAL_SUCCESS;
+}
+
+
+
+
+/** @} */
+
+/** @} */
+
+/* *********************************************************************************/
+/* The following private function generates IMRPhenomD frequency-domain waveforms  */
+/* given coefficients */
+/* *********************************************************************************/
+
+static int IMRPhenomDGenerateFDAmpPhs(
+    COMPLEX16FrequencySeries **amplitude, /**< [out] FD amplitude */
+    COMPLEX16FrequencySeries **phase,  /**< [out] FD phase */
+    const REAL8Sequence *freqs_in,     /**< Frequency points at which to evaluate the waveform (Hz) */
+    double deltaF,                     /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+                                        * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+                                        * Then we will use deltaF = 0 to create the frequency series we return. */
+    const REAL8 phi0,                  /**< phase at fRef */
+    const REAL8 fRef,                  /**< reference frequency [Hz] */
+    const REAL8 m1_in,                 /**< mass of companion 1 [solar masses] */
+    const REAL8 m2_in,                 /**< mass of companion 2 [solar masses] */
+    const REAL8 chi1_in,               /**< aligned-spin of companion 1 */
+    const REAL8 chi2_in,               /**< aligned-spin of companion 2 */
+    const REAL8 distance,              /**< distance to source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+) {
+  LIGOTimeGPS ligotimegps_zero = LIGOTIMEGPSZERO; // = {0, 0}
+
+  // Make a pointer to LALDict to circumvent a memory leak
+  // At the end we will check if we created a LALDict in extraParams
+  // and destroy it if we did.
+  LALDict *extraParams_in = extraParams;
+  REAL8Sequence *amp_tidal = NULL; /* Tidal amplitude series; required only for IMRPhenomD_NRTidalv2 */
+  REAL8 dquadmon1_in = 0., dquadmon2_in = 0., lambda1_in = 0, lambda2_in = 0.;
+  if (NRTidal_version == NRTidalv2_V) {
+    dquadmon1_in = XLALSimInspiralWaveformParamsLookupdQuadMon1(extraParams);
+    dquadmon2_in = XLALSimInspiralWaveformParamsLookupdQuadMon2(extraParams);
+    lambda1_in = XLALSimInspiralWaveformParamsLookupTidalLambda1(extraParams);
+    lambda2_in = XLALSimInspiralWaveformParamsLookupTidalLambda2(extraParams);
+  }
+
+  REAL8 chi1, chi2, m1, m2, dquadmon1, dquadmon2, lambda1, lambda2;
+  if (m1_in>=m2_in) {
+     chi1 = chi1_in;
+     chi2 = chi2_in;
+     m1   = m1_in;
+     m2   = m2_in;
+     dquadmon1 = dquadmon1_in;
+     dquadmon2 = dquadmon2_in;
+     lambda1 = lambda1_in;
+     lambda2 = lambda2_in;
+  } else { // swap spins and masses
+     chi1 = chi2_in;
+     chi2 = chi1_in;
+     m1   = m2_in;
+     m2   = m1_in;
+     dquadmon1 = dquadmon2_in;
+     dquadmon2 = dquadmon1_in;
+     lambda1 = lambda2_in;
+     lambda2 = lambda1_in;
+     if (NRTidal_version == NRTidalv2_V) {
+       XLALSimInspiralWaveformParamsInsertdQuadMon1(extraParams, dquadmon1);
+       XLALSimInspiralWaveformParamsInsertdQuadMon2(extraParams, dquadmon2);
+     }
+  }
+
+  int status = init_useful_powers(&powers_of_pi, LAL_PI);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initiate useful powers of pi.");
+
+  /* Find frequency bounds */
+  if (!freqs_in || !freqs_in->data) XLAL_ERROR(XLAL_EFAULT);
+  double f_min = freqs_in->data[0];
+  double f_max = freqs_in->data[freqs_in->length - 1];
+  XLAL_CHECK(f_min > 0, XLAL_EDOM, "Minimum frequency must be positive.\n");
+  XLAL_CHECK(f_max >= 0, XLAL_EDOM, "Maximum frequency must be non-negative.\n");
+
+  const REAL8 M = m1 + m2;
+  REAL8 eta = m1 * m2 / (M * M);
+
+  if (eta > 0.25)
+      PhenomInternal_nudge(&eta, 0.25, 1e-6);
+  if (eta > 0.25 || eta < 0.0)
+      XLAL_ERROR(XLAL_EDOM, "Unphysical eta. Must be between 0. and 0.25\n");
+
+  const REAL8 M_sec = M * LAL_MTSUN_SI;
+
+  /* Compute the amplitude pre-factor */
+  const REAL8 amp0 = 2. * sqrt(5. / (64.*LAL_PI)) * M * LAL_MRSUN_SI * M * LAL_MTSUN_SI / distance;
+
+  size_t npts = 0;
+  UINT4 offset = 0; // Index shift between freqs and the frequency series
+  REAL8Sequence *freqs = NULL;
+  if (deltaF > 0)  { // freqs contains uniform frequency grid with spacing deltaF; we start at frequency 0
+    /* Set up output array with size closest power of 2 */
+    npts = NextPow2(f_max / deltaF) + 1;
+    /* Coalesce at t=0 */
+    // shift by overall length in time
+    XLAL_CHECK ( XLALGPSAdd(&ligotimegps_zero, -1. / deltaF), XLAL_EFUNC, "Failed to shift coalescence time to t=0, tried to apply shift of -1.0/deltaF with deltaF=%g.", deltaF);
+    *amplitude = XLALCreateCOMPLEX16FrequencySeries("amplitude: FD waveform", &ligotimegps_zero, 0.0, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *amplitude, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu for f_max=%f, deltaF=%g.", npts, f_max, deltaF);
+    *phase = XLALCreateCOMPLEX16FrequencySeries("phase: FD waveform", &ligotimegps_zero, 0.0, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *phase, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu for f_max=%f, deltaF=%g.", npts, f_max, deltaF);
+    // Recreate freqs using only the lower and upper bounds
+    size_t iStart = (size_t) (f_min / deltaF);
+    size_t iStop = (size_t) (f_max / deltaF);
+    XLAL_CHECK ( (iStop<=npts) && (iStart<=iStop), XLAL_EDOM, "minimum freq index %zu and maximum freq index %zu do not fulfill 0<=ind_min<=ind_max<=htilde->data>length=%zu.", iStart, iStop, npts);
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    if (!freqs)
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    for (UINT4 i=iStart; i<iStop; i++)
+      freqs->data[i-iStart] = i*deltaF;
+    offset = iStart;
+  } else { // freqs contains frequencies with non-uniform spacing; we start at lowest given frequency
+    npts = freqs_in->length;
+    *amplitude = XLALCreateCOMPLEX16FrequencySeries("amplitude: FD waveform", &ligotimegps_zero, f_min, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *amplitude, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu from sequence.", npts);
+    *phase = XLALCreateCOMPLEX16FrequencySeries("phase: FD waveform", &ligotimegps_zero, f_min, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *phase, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu from sequence.", npts);
+    offset = 0;
+    freqs = XLALCreateREAL8Sequence(freqs_in->length);
+    if (!freqs)
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    for (UINT4 i=0; i<freqs_in->length; i++)
+      freqs->data[i] = freqs_in->data[i];
+  }
+
+  memset((*amplitude)->data->data, 0, npts * sizeof(COMPLEX16));
+  XLALUnitMultiply(&((*amplitude)->sampleUnits), &((*amplitude)->sampleUnits), &lalSecondUnit);
+  
+  memset((*phase)->data->data, 0, npts * sizeof(COMPLEX16));
+  XLALUnitMultiply(&((*phase)->sampleUnits), &((*phase)->sampleUnits), &lalSecondUnit);
+
+  // Calculate phenomenological parameters
+  const REAL8 finspin = FinalSpin0815(eta, chi1, chi2); //FinalSpin0815 - 0815 is like a version number
+
+  if (finspin < MIN_FINAL_SPIN)
+          XLAL_PRINT_WARNING("Final spin (Mf=%g) and ISCO frequency of this system are small, \
+                          the model might misbehave here.", finspin);
+
+  IMRPhenomDAmplitudeCoefficients *pAmp;
+  pAmp = XLALMalloc(sizeof(IMRPhenomDAmplitudeCoefficients));
+  ComputeIMRPhenomDAmplitudeCoefficients(pAmp, eta, chi1, chi2, finspin);
+  if (!pAmp) XLAL_ERROR(XLAL_EFUNC);
+  if (extraParams==NULL)
+    extraParams=XLALCreateDict();
+  XLALSimInspiralWaveformParamsInsertPNSpinOrder(extraParams,LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
+  IMRPhenomDPhaseCoefficients *pPhi;
+  pPhi = XLALMalloc(sizeof(IMRPhenomDPhaseCoefficients));
+  ComputeIMRPhenomDPhaseCoefficients(pPhi, eta, chi1, chi2, finspin, extraParams);
+  if (!pPhi) XLAL_ERROR(XLAL_EFUNC);
+  PNPhasingSeries *pn = NULL;
+  XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1, chi2, extraParams);
+  if (!pn) XLAL_ERROR(XLAL_EFUNC);
+
+  // Subtract 3PN spin-spin term below as this is in LAL's TaylorF2 implementation
+  // (LALSimInspiralPNCoefficients.c -> XLALSimInspiralPNPhasing_F2), but
+  REAL8 testGRcor=1.0;
+  testGRcor += XLALSimInspiralWaveformParamsLookupNonGRDChi6(extraParams);
+
+  // was not available when PhenomD was tuned.
+  pn->v[6] -= (Subtract3PNSS(m1, m2, M, eta, chi1, chi2) * pn->v[0]) * testGRcor;
+
+  PhiInsPrefactors phi_prefactors;
+  status = init_phi_ins_prefactors(&phi_prefactors, pPhi, pn);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_phi_ins_prefactors failed");
+
+  // Compute coefficients to make phase C^1 continuous (phase and first derivative)
+  ComputeIMRPhenDPhaseConnectionCoefficients(pPhi, pn, &phi_prefactors, 1.0, 1.0);
+
+  //time shift so that peak amplitude is approximately at t=0
+  //For details see https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview/timedomain
+  const REAL8 t0 = DPhiMRD(pAmp->fmaxCalc, pPhi, 1.0, 1.0);
+
+  AmpInsPrefactors amp_prefactors;
+  status = init_amp_ins_prefactors(&amp_prefactors, pAmp);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_amp_ins_prefactors failed");
+
+  // incorporating fRef
+  const REAL8 MfRef = M_sec * fRef;
+  UsefulPowers powers_of_fRef;
+  status = init_useful_powers(&powers_of_fRef, MfRef);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_useful_powers failed for MfRef");
+  const REAL8 phifRef = IMRPhenDPhase(MfRef, pPhi, pn, &powers_of_fRef, &phi_prefactors, 1.0, 1.0);
+
+  // factor of 2 b/c phi0 is orbital phase
+  const REAL8 phi_precalc = 2.*phi0 + phifRef;
+
+  int status_in_for = XLAL_SUCCESS;
+  int ret = XLAL_SUCCESS;
+  /* Now generate the waveform */
+  if (NRTidal_version == NRTidalv2_V) {
+    /* Generate the tidal amplitude (Eq. 24 of arxiv: 1905.06011) to add to BBH baseline; only for IMRPhenomD_NRTidalv2 */
+    amp_tidal = XLALCreateREAL8Sequence(freqs->length);
+    ret = XLALSimNRTunedTidesFDTidalAmplitudeFrequencySeries(amp_tidal, freqs, m1, m2, lambda1, lambda2);
+    XLAL_CHECK(XLAL_SUCCESS == ret, ret, "Failed to generate tidal amplitude series to construct IMRPhenomD_NRTidalv2 waveform.");
+    /* Generated tidal amplitude corrections */
+    #pragma omp parallel for
+    for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double Mf = M_sec * freqs->data[i];
+      double ampT = amp_tidal->data[i];
+      int j = i + offset; // shift index for frequency series if needed
+
+      UsefulPowers powers_of_f;
+      status_in_for = init_useful_powers(&powers_of_f, Mf);
+      if (XLAL_SUCCESS != status_in_for)
+      {
+        XLALPrintError("init_useful_powers failed for Mf, status_in_for=%d", status_in_for);
+        status = status_in_for;
+      }
+      else {
+        REAL8 amp = IMRPhenDAmplitude(Mf, pAmp, &powers_of_f, &amp_prefactors);
+        REAL8 phi = IMRPhenDPhase(Mf, pPhi, pn, &powers_of_f, &phi_prefactors, 1.0, 1.0);
+
+        phi -= t0*(Mf-MfRef) + phi_precalc;
+        ((*amplitude)->data->data)[j] =  amp0 * (amp+2*sqrt(LAL_PI/5.)*ampT)  ;
+        ((*phase)->data->data)[j] = phi ;
+      }
+    }
+  } else {
+      #pragma omp parallel for
+      for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double Mf = M_sec * freqs->data[i];
+      int j = i + offset; // shift index for frequency series if needed
+
+      UsefulPowers powers_of_f;
+      status_in_for = init_useful_powers(&powers_of_f, Mf);
+      if (XLAL_SUCCESS != status_in_for)
+      {
+        XLALPrintError("init_useful_powers failed for Mf, status_in_for=%d", status_in_for);
+        status = status_in_for;
+      }
+      else {
+        REAL8 amp = IMRPhenDAmplitude(Mf, pAmp, &powers_of_f, &amp_prefactors);
+        REAL8 phi = IMRPhenDPhase(Mf, pPhi, pn, &powers_of_f, &phi_prefactors, 1.0, 1.0);
+        
+        phi -= t0*(Mf-MfRef) + phi_precalc;
+        ((*amplitude)->data->data)[j] = amp0 * amp ;
+        ((*phase)->data->data)[j] = phi ;
+      }
+    }
+  }
+
+  LALFree(pAmp);
+  LALFree(pPhi);
+  LALFree(pn);
+  XLALDestroyREAL8Sequence(freqs);
+  XLALDestroyREAL8Sequence(amp_tidal);
+
+
+  /* If extraParams was allocated in this function and not passed in
+   * we need to free it to prevent a leak */
+  if (extraParams && !extraParams_in) {
+    XLALDestroyDict(extraParams);
+  } else {
+    XLALSimInspiralWaveformParamsInsertPNSpinOrder(extraParams,LAL_SIM_INSPIRAL_SPIN_ORDER_ALL);
+  }
+
+  return status;
+}
+
diff --git a/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c b/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
index 5a83110506..b9280ea05c 100644
--- a/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
+++ b/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
@@ -1616,3 +1616,480 @@ UNUSED static void SEOBNRv4ROM_Init_LALDATA(void)
   XLAL_ERROR_VOID(XLAL_EFAILED, "SEOBNRv4ROM requires HDF5 support which is not enabled\n");
 #endif
 }
+
+
+
+
+
+
+/**Private function to compute the SEOBNRV4ROM amplitude and phase **/
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+UNUSED static int SEOBNRv4ROMCoreAmpPhs(
+  COMPLEX16FrequencySeries **hptilde,	/**< Output: Frequency-domain waveform h+ */
+  COMPLEX16FrequencySeries **hctilde,	/**< Output: Frequency-domain waveform hx */
+  double phiRef,			/**< Orbital phase (rad) */
+  double fRef,				/**< Reference frequency */
+  double distance,			/**< Distance of source (m) */
+  double inclination,			/**< Inclination angle of source (rad) */
+  double Mtot_sec,			/**< Total source mass in seconds */
+  double eta,				/**< Symmetric mass ratio */
+  double chi1,				/**< Dimensionless aligned spin on companion 1 */
+  double chi2,				/**< Dimensionless aligned spin on companion 2 */
+  const REAL8Sequence *freqs, /* Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF,			/**< Sampling frequency (Hz).
+   * If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+  int nk_max, // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+);
+
+
+
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi1, chi2).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+static int SEOBNRv4ROMCoreAmpPhs(
+  COMPLEX16FrequencySeries **hptilde,	/**< [out] Frequency-domain waveform h+ */
+  COMPLEX16FrequencySeries **hctilde,	/**< [out] Frequency-domain waveform hx */
+  double phiRef, 			/**< orbital reference phase */
+  double fRef,				/**< Reference frequency */
+  double distance,			/**< Distance of source (m) */
+  double inclination,			/**< Inclination of source */
+  double Mtot_sec,			/**< Total mass of source in seconds */
+  double eta,				/**< Symmetric mass ratio */
+  double chi1,				/**< Dimensionless spin aligned spin on companion 1 */
+  double chi2,				/**< Dimensionless aligned spin on companion 2 */
+  const REAL8Sequence *freqs_in, 	/**< Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF,			/**< Sampling frequency (Hz).
+   * If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+  int nk_max, 				/**< truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+  )
+{
+
+  /* Check output arrays */
+  if(!hptilde || !hctilde)
+    XLAL_ERROR(XLAL_EFAULT);
+
+  SEOBNRROMdataDS *romdata=&__lalsim_SEOBNRv4ROMDS_data;
+  if (!SEOBNRv4ROM_IsSetup()) {
+    XLAL_ERROR(XLAL_EFAILED,
+               "Error setting up SEOBNRv4ROM data - check your $LAL_DATA_PATH\n");
+  }
+
+  if(*hptilde || *hctilde) {
+    XLALPrintError("(*hptilde) and (*hctilde) are supposed to be NULL, but got %p and %p",
+                   (*hptilde), (*hctilde));
+    XLAL_ERROR(XLAL_EFAULT);
+  }
+  int retcode=0;
+
+  // 'Nudge' parameter values to allowed boundary values if close by
+  if (eta > 0.25)     nudge(&eta, 0.25, 1e-6);
+  if (eta < 0.01)     nudge(&eta, 0.01, 1e-6);
+
+  if ( chi1 < -1.0 || chi2 < -1.0 || chi1 > 1.0 || chi2 > 1.0) {
+    XLALPrintError("XLAL Error - %s: chi1 or chi2 smaller than -1.0 or larger than 1.0!\n"
+                   "SEOBNRv4ROM is only available for spins in the range -1 <= a/M <= 1.0.\n",
+                   __func__);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  if (eta<0.01 || eta > 0.25) {
+    XLALPrintError("XLAL Error - %s: eta (%f) smaller than 0.01 or unphysical!\n"
+                   "SEOBNRv4ROM is only available for eta in the range 0.01 <= eta <= 0.25.\n",
+                   __func__, eta);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  /* We always need to glue two submodels together for this ROM */
+  SEOBNRROMdataDS_submodel *submodel_hi; // high frequency ROM
+  SEOBNRROMdataDS_submodel *submodel_lo; // low frequency ROM
+  submodel_lo = romdata->sub1;
+
+  /* Select high frequency ROM submodel */
+  if (chi1 < romdata->sub3->chi1_bounds[0] || eta > romdata->sub3->eta_bounds[1]) // only check the two conditions that apply for this ROM; could be more general, but slower
+    submodel_hi = romdata->sub2;
+  else
+    submodel_hi = romdata->sub3;
+
+
+  /* Find frequency bounds */
+  if (!freqs_in) XLAL_ERROR(XLAL_EFAULT);
+  double fLow  = freqs_in->data[0];
+  double fHigh = freqs_in->data[freqs_in->length - 1];
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  /* Convert to geometric units for frequency */
+  // lowest allowed geometric frequency for ROM
+  double Mf_ROM_min = fmax(gsl_vector_get(submodel_lo->gA, 0),
+                           gsl_vector_get(submodel_lo->gPhi,0));
+  // highest allowed geometric frequency for ROM
+  double Mf_ROM_max = fmin(gsl_vector_get(submodel_hi->gA, submodel_hi->nk_amp-1),
+                           gsl_vector_get(submodel_hi->gPhi, submodel_hi->nk_phi-1));
+  double fLow_geom = fLow * Mtot_sec;
+  double fHigh_geom = fHigh * Mtot_sec;
+  double fRef_geom = fRef * Mtot_sec;
+  double deltaF_geom = deltaF * Mtot_sec;
+
+  // Enforce allowed geometric frequency range
+  if (fLow_geom < Mf_ROM_min)
+    XLAL_ERROR(XLAL_EDOM, "Starting frequency Mflow=%g is smaller than lowest frequency in ROM Mf=%g.\n", fLow_geom, Mf_ROM_min);
+  if (fHigh_geom == 0 || fHigh_geom > Mf_ROM_max)
+    fHigh_geom = Mf_ROM_max;
+  else if (fHigh_geom < Mf_ROM_min)
+    XLAL_ERROR(XLAL_EDOM, "End frequency %g is smaller than ROM starting frequency %g!\n", fHigh_geom, Mf_ROM_min);
+  if (fHigh_geom <= fLow_geom)
+    XLAL_ERROR(XLAL_EDOM, "End frequency %g is smaller than (or equal to) starting frequency %g!\n", fHigh_geom, fLow_geom);
+  if (fRef_geom > Mf_ROM_max) {
+    XLALPrintWarning("Reference frequency Mf_ref=%g is greater than maximal frequency in ROM Mf=%g. Starting at maximal frequency in ROM.\n", fRef_geom, Mf_ROM_max);
+    fRef_geom = Mf_ROM_max; // If fref > fhigh we reset fref to default value of cutoff frequency.
+  }
+  if (fRef_geom < Mf_ROM_min) {
+    XLALPrintWarning("Reference frequency Mf_ref=%g is smaller than lowest frequency in ROM Mf=%g. Starting at lowest frequency in ROM.\n", fLow_geom, Mf_ROM_min);
+    fRef_geom = Mf_ROM_min;
+  }
+
+  if (Mtot_sec/LAL_MTSUN_SI > 500.0)
+    XLALPrintWarning("Total mass=%gMsun > 500Msun. SEOBNRv4ROM disagrees with SEOBNRv4 for high total masses.\n", Mtot_sec/LAL_MTSUN_SI);
+
+  /* Internal storage for waveform coefficiencts */
+  SEOBNRROMdataDS_coeff *romdata_coeff_lo=NULL;
+  SEOBNRROMdataDS_coeff *romdata_coeff_hi=NULL;
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff_lo, submodel_lo->nk_amp, submodel_lo->nk_phi);
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff_hi, submodel_hi->nk_amp, submodel_hi->nk_phi);
+  REAL8 amp_pre_lo = 1.0; // unused here
+  REAL8 amp_pre_hi = 1.0;
+
+  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
+  retcode=TP_Spline_interpolation_3d(
+    eta,                          // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
+    submodel_lo->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel_lo->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel_lo->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel_lo->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+    submodel_lo->ncx,             // Number of points in eta  + 2
+    submodel_lo->ncy,             // Number of points in chi1 + 2
+    submodel_lo->ncz,             // Number of points in chi2 + 2
+    gsl_vector_const_ptr(submodel_lo->etavec, 0),          // B-spline knots in eta
+    gsl_vector_const_ptr(submodel_lo->chi1vec, 0),        // B-spline knots in chi1
+    gsl_vector_const_ptr(submodel_lo->chi2vec, 0),        // B-spline knots in chi2
+    romdata_coeff_lo->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff_lo->c_phi       // Output: interpolated projection coefficients for phase
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+    XLAL_ERROR(retcode);
+  }
+
+  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
+  retcode=TP_Spline_interpolation_3d(
+    eta,                          // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
+    submodel_hi->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel_hi->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel_hi->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel_hi->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+    submodel_hi->ncx,             // Number of points in eta  + 2
+    submodel_hi->ncy,             // Number of points in chi1 + 2
+    submodel_hi->ncz,             // Number of points in chi2 + 2
+    gsl_vector_const_ptr(submodel_hi->etavec, 0),         // B-spline knots in eta
+    gsl_vector_const_ptr(submodel_hi->chi1vec, 0),        // B-spline knots in chi1
+    gsl_vector_const_ptr(submodel_hi->chi2vec, 0),        // B-spline knots in chi2
+    romdata_coeff_hi->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff_hi->c_phi       // Output: interpolated projection coefficients for phase
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+    XLAL_ERROR(retcode);
+  }
+
+
+  // Compute function values of amplitude an phase on sparse frequency points by evaluating matrix vector products
+  // amp_pts = B_A^T . c_A
+  // phi_pts = B_phi^T . c_phi
+  gsl_vector* amp_f_lo = gsl_vector_alloc(submodel_lo->nk_amp);
+  gsl_vector* phi_f_lo = gsl_vector_alloc(submodel_lo->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bamp, romdata_coeff_lo->c_amp, 0.0, amp_f_lo);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bphi, romdata_coeff_lo->c_phi, 0.0, phi_f_lo);
+
+  gsl_vector* amp_f_hi = gsl_vector_alloc(submodel_hi->nk_amp);
+  gsl_vector* phi_f_hi = gsl_vector_alloc(submodel_hi->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bamp, romdata_coeff_hi->c_amp, 0.0, amp_f_hi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bphi, romdata_coeff_hi->c_phi, 0.0, phi_f_hi);
+
+  const double Mfm = 0.01; // Gluing frequency: the low and high frequency ROMs overlap here; this is used both for amplitude and phase.
+
+  // Glue amplitude
+  gsl_interp_accel *acc_amp;
+  gsl_spline *spline_amp;
+  GlueAmplitude(submodel_lo, submodel_hi, amp_f_lo, amp_f_hi, amp_pre_lo, amp_pre_hi, Mfm,
+    &acc_amp, &spline_amp
+  );
+
+  // Glue phasing in frequency to C^1 smoothness
+  gsl_interp_accel *acc_phi;
+  gsl_spline *spline_phi;
+  GluePhasing(submodel_lo, submodel_hi, phi_f_lo, phi_f_hi, Mfm,
+    &acc_phi, &spline_phi
+  );
+
+  size_t npts = 0;
+  LIGOTimeGPS tC = {0, 0};
+  UINT4 offset = 0; // Index shift between freqs and the frequency series
+  REAL8Sequence *freqs = NULL;
+  REAL8Sequence *amp_tidal = NULL; /* Tidal amplitude series; required only for SEOBNRv4_ROM_NRTidalv2 */
+  if (deltaF > 0)  { // freqs contains uniform frequency grid with spacing deltaF; we start at frequency 0
+    /* Set up output array with size closest power of 2 */
+    npts = NextPow2(fHigh_geom / deltaF_geom) + 1;
+    if (fHigh_geom < fHigh * Mtot_sec) /* Resize waveform if user wants f_max larger than cutoff frequency */
+      npts = NextPow2(fHigh * Mtot_sec / deltaF_geom) + 1;
+
+    XLALGPSAdd(&tC, -1. / deltaF);  /* coalesce at t=0 */
+    *hptilde = XLALCreateCOMPLEX16FrequencySeries("hptilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+    *hctilde = XLALCreateCOMPLEX16FrequencySeries("hctilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+
+    // Recreate freqs using only the lower and upper bounds
+    // Use fLow, fHigh and deltaF rather than geometric frequencies for numerical accuracy
+    double fHigh_temp = fHigh_geom / Mtot_sec;
+    UINT4 iStart = (UINT4) ceil(fLow / deltaF);
+    UINT4 iStop = (UINT4) ceil(fHigh_temp / deltaF);
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    if (!freqs) {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+    for (UINT4 i=iStart; i<iStop; i++)
+      freqs->data[i-iStart] = i*deltaF_geom;
+
+    offset = iStart;
+  } else { // freqs contains frequencies with non-uniform spacing; we start at lowest given frequency
+    npts = freqs_in->length;
+    *hptilde = XLALCreateCOMPLEX16FrequencySeries("hptilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    *hctilde = XLALCreateCOMPLEX16FrequencySeries("hctilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    offset = 0;
+
+    freqs = XLALCreateREAL8Sequence(freqs_in->length);
+    if (!freqs) {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+    for (UINT4 i=0; i<freqs_in->length; i++)
+      freqs->data[i] = freqs_in->data[i] * Mtot_sec;
+  }
+
+  if (!(*hptilde) || !(*hctilde))	{
+      XLALDestroyREAL8Sequence(freqs);
+      gsl_spline_free(spline_amp);
+      gsl_spline_free(spline_phi);
+      gsl_interp_accel_free(acc_amp);
+      gsl_interp_accel_free(acc_phi);
+      SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+      SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+      XLAL_ERROR(XLAL_EFUNC);
+  }
+  memset((*hptilde)->data->data, 0, npts * sizeof(COMPLEX16));
+  memset((*hctilde)->data->data, 0, npts * sizeof(COMPLEX16));
+
+  XLALUnitMultiply(&(*hptilde)->sampleUnits, &(*hptilde)->sampleUnits, &lalSecondUnit);
+  XLALUnitMultiply(&(*hctilde)->sampleUnits, &(*hctilde)->sampleUnits, &lalSecondUnit);
+
+  COMPLEX16 *pdata=(*hptilde)->data->data;
+  COMPLEX16 *cdata=(*hctilde)->data->data;
+
+  REAL8 cosi = cos(inclination);
+  REAL8 pcoef = 0.5*(1.0 + cosi*cosi);
+  //REAL8 ccoef = cosi;
+
+  REAL8 s = 0.5; // Scale polarization amplitude so that strain agrees with FFT of SEOBNRv4
+  double Mtot = Mtot_sec / LAL_MTSUN_SI;
+  double amp0 = Mtot * Mtot_sec * LAL_MRSUN_SI / (distance); // Correct overall amplitude to undo mass-dependent scaling used in ROM
+
+  // Evaluate reference phase for setting phiRef correctly
+  double phase_change = gsl_spline_eval(spline_phi, fRef_geom, acc_phi) - 2*phiRef;
+  
+  int ret = XLAL_SUCCESS;
+  // Assemble waveform from aplitude and phase
+  if (NRTidal_version == NRTidalv2_V) {
+    /* get component masses (in solar masses) from mtotal and eta! */
+    const REAL8 factor = sqrt(1. - 4.*eta);
+    const REAL8 m1 = 0.5*Mtot*(1.+ factor);
+    const REAL8 m2 = 0.5*Mtot*(1.- factor);
+    /* Generate the tidal amplitude (Eq. 24 of arxiv: 1905.06011) to add to BBH baseline; only for NRTidalv2 */
+    amp_tidal = XLALCreateREAL8Sequence(freqs->length);
+    const REAL8 l1 = XLALSimInspiralWaveformParamsLookupTidalLambda1(LALparams);
+    const REAL8 l2 = XLALSimInspiralWaveformParamsLookupTidalLambda2(LALparams);
+
+    ret = XLALSimNRTunedTidesFDTidalAmplitudeFrequencySeries(amp_tidal, freqs, m1, m2, l1, l2);
+    XLAL_CHECK(XLAL_SUCCESS == ret, ret, "Failed to generate tidal amplitude series to construct SEOBNRv4_ROM_NRTidalv2 waveform.");
+    /* Generated tidal amplitude corrections */
+    for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double f = freqs->data[i];
+      double ampT = amp_tidal->data[i];
+
+      if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+      int j = i + offset; // shift index for frequency series if needed
+      double A = gsl_spline_eval(spline_amp, f, acc_amp);
+      double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
+      //COMPLEX16 htilde = s*amp0*(A+ampT) * (cos(phase) + I*sin(phase)); //cexp(I*phase);
+      pdata[j] =  pcoef *  s*amp0*(A+ampT);
+      cdata[j] = phase;
+    }
+  } else {
+      for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+        double f = freqs->data[i];
+        if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+        int j = i + offset; // shift index for frequency series if needed
+        double A = gsl_spline_eval(spline_amp, f, acc_amp);
+        double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
+        //COMPLEX16 htilde = s*amp0*A * (cos(phase) + I*sin(phase));//cexp(I*phase);
+
+        pdata[j] =  pcoef * s*amp0*A;
+        cdata[j] = phase;
+      }
+   }
+
+  /* Correct phasing so we coalesce at t=0 (with the definition of the epoch=-1/deltaF above) */
+
+  // Get SEOBNRv4 ringdown frequency for 22 mode
+  double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(Mtot_sec, eta, chi1,
+                                                        chi2, SEOBNRv4);
+
+  // prevent gsl interpolation errors
+  // The ringdown frequency Mf_final is only used to evaluate the spline_phi
+  // derivative below and spline_phi has domain [Mf_ROM_min, Mf_ROM_max].
+  // Mf_final should always be inside this interval, but we'll check anyway.
+  if (Mf_final > Mf_ROM_max)
+    Mf_final = Mf_ROM_max;
+  if (Mf_final < Mf_ROM_min) {
+    XLALDestroyREAL8Sequence(freqs);
+    gsl_spline_free(spline_amp);
+    gsl_spline_free(spline_phi);
+    gsl_interp_accel_free(acc_amp);
+    gsl_interp_accel_free(acc_phi);
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+    XLAL_ERROR(XLAL_EDOM, "f_ringdown < f_min");
+  }
+
+  // Time correction is t(f_final) = 1/(2pi) dphi/df (f_final)
+  // We compute the dimensionless time correction t/M since we use geometric units.
+  REAL8 t_corr = gsl_spline_eval_deriv(spline_phi, Mf_final, acc_phi) / (2*LAL_PI);
+
+  // Now correct phase
+  for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+    double f = freqs->data[i] - fRef_geom;
+    int j = i + offset; // shift index for frequency series if needed
+    double phase_factor = -2*LAL_PI * f * t_corr;
+    //COMPLEX16 t_factor = (cos(phase_factor) + I*sin(phase_factor));//cexp(I*phase_factor);
+    //pdata[j] *= t_factor;
+    cdata[j] += phase_factor;
+  }
+
+  XLALDestroyREAL8Sequence(freqs);
+  XLALDestroyREAL8Sequence(amp_tidal);
+
+  gsl_spline_free(spline_amp);
+  gsl_spline_free(spline_phi);
+  gsl_interp_accel_free(acc_amp);
+  gsl_interp_accel_free(acc_phi);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+
+  return(XLAL_SUCCESS);
+}
+
+
+
+/**
+ * Compute waveform in LAL format for the SEOBNRv4_ROM model.
+ *
+ * Returns the plus and cross polarizations as a complex frequency series with
+ * equal spacing deltaF and contains zeros from zero frequency to the starting
+ * frequency fLow and zeros beyond the cutoff frequency in the ringdown.
+ */
+int XLALSimIMRSEOBNRv4ROMAmpPhs(
+  struct tagCOMPLEX16FrequencySeries **hptilde, /**< Output: Frequency-domain waveform h+ */
+  struct tagCOMPLEX16FrequencySeries **hctilde, /**< Output: Frequency-domain waveform hx */
+  REAL8 phiRef,                                 /**< Phase at reference time */
+  REAL8 deltaF,                                 /**< Sampling frequency (Hz) */
+  REAL8 fLow,                                   /**< Starting GW frequency (Hz) */
+  REAL8 fHigh,                                  /**< End frequency; 0 defaults to Mf=0.14 */
+  REAL8 fRef,                                   /**< Reference frequency (Hz); 0 defaults to fLow */
+  REAL8 distance,                               /**< Distance of source (m) */
+  REAL8 inclination,                            /**< Inclination of source (rad) */
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2,                                   /**< Dimensionless aligned component spin 2 */
+  INT4 nk_max,                                  /**< Truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version 		/**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+)
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  /* Get masses in terms of solar mass */
+  double mass1 = m1SI / LAL_MSUN_SI;
+  double mass2 = m2SI / LAL_MSUN_SI;
+  double Mtot = mass1+mass2;
+  double eta = mass1 * mass2 / (Mtot*Mtot);    /* Symmetric mass-ratio */
+  double Mtot_sec = Mtot * LAL_MTSUN_SI;       /* Total mass in seconds */
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  // Load ROM data if not loaded already
+#ifdef LAL_PTHREAD_LOCK
+  (void) pthread_once(&SEOBNRv4ROM_is_initialized, SEOBNRv4ROM_Init_LALDATA);
+#else
+  SEOBNRv4ROM_Init_LALDATA();
+#endif
+
+  // Use fLow, fHigh, deltaF to compute freqs sequence
+  // Instead of building a full sequency we only transfer the boundaries and let
+  // the internal core function do the rest (and properly take care of corner cases).
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = fLow;
+  freqs->data[1] = fHigh;
+
+  int retcode = SEOBNRv4ROMCoreAmpPhs(hptilde, hctilde, phiRef, fRef, distance,
+                                inclination, Mtot_sec, eta, chi1, chi2, freqs,
+                                deltaF, nk_max, LALparams, NRTidal_version);
+
+  XLALDestroyREAL8Sequence(freqs);
+
+  return(retcode);
+}
+
