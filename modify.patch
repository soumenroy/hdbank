diff --git a/lalinspiral/python/lalinspiral/sbank/tau0tau3.py b/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
index 4cd3ebf00a..0127643c22 100644
--- a/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
+++ b/lalinspiral/python/lalinspiral/sbank/tau0tau3.py
@@ -242,7 +242,7 @@ def tau0tau3_bound(flow, **constraints):
     # FIXME: As this is discrete, this can cause the bank sizes to be smaller
     # than expected. Raising this to 1e5, raising it higher starts to cause
     # slowdown as computing m2 from m1 and mchirp is expensive.
-    npts = 1e4
+    npts = int(1e4)
 
     # draw constant component mass lines
     m1min, m1max = constraints['mass1']
diff --git a/lalsimulation/lib/LALSimIMR.h b/lalsimulation/lib/LALSimIMR.h
index 75e39d60fa..de98674c25 100644
--- a/lalsimulation/lib/LALSimIMR.h
+++ b/lalsimulation/lib/LALSimIMR.h
@@ -149,6 +149,8 @@ int XLALSimIMRPhenomDFrequencySequence(COMPLEX16FrequencySeries **htilde, const
 double XLALIMRPhenomDGetPeakFreq(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in);
 double XLALSimIMRPhenomDChirpTime(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in, const REAL8 fHz);
 double XLALSimIMRPhenomDFinalSpin(const REAL8 m1_in, const REAL8 m2_in, const REAL8 chi1_in, const REAL8 chi2_in);
+int XLALSimIMRPhenomDGenerateFDAmpPhs(REAL8FrequencySeries **wfamplitude, REAL8FrequencySeries **wfphase, const REAL8 phi0, const REAL8 fRef, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 chi1, const REAL8 chi2, const REAL8 f_min, const REAL8 f_max, const REAL8 distance, LALDict *extraParams, NRTidal_version_type NRTidal_version);
+
 
 int XLALSimIMRPhenomP(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 deltaF, const REAL8 f_min, const REAL8 f_max, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version, NRTidal_version_type NRTidal_version, LALDict *extraParams);
 int XLALSimIMRPhenomPFrequencySequence(COMPLEX16FrequencySeries **hptilde, COMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, const REAL8 chi1_l, const REAL8 chi2_l, const REAL8 chip, const REAL8 thetaJ, REAL8 m1_SI, const REAL8 m2_SI, const REAL8 distance, const REAL8 alpha0, const REAL8 phic, const REAL8 f_ref, IMRPhenomP_version_type IMRPhenomP_version, NRTidal_version_type NRTidal_version, LALDict *extraParams);
@@ -360,6 +362,7 @@ int XLALSimIMRLackeyTidal2013FrequencySequence(struct tagCOMPLEX16FrequencySerie
 /* in module LALSimIMRSEOBNRv4ROM.c */
 
 int XLALSimIMRSEOBNRv4ROM(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
+int XLALSimIMRSEOBNRv4ROMAmpPhs(struct tagREAL8FrequencySeries **wfamplitude, struct tagREAL8FrequencySeries **wfphase, REAL8 phiRef, REAL8 deltaF, REAL8 fLow, REAL8 fHigh, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
 int XLALSimIMRSEOBNRv4ROMFrequencySequence(struct tagCOMPLEX16FrequencySeries **hptilde, struct tagCOMPLEX16FrequencySeries **hctilde, const REAL8Sequence *freqs, REAL8 phiRef, REAL8 fRef, REAL8 distance, REAL8 inclination, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2, INT4 nk_max, LALDict *LALparams, NRTidal_version_type NRTidal_version);
 int XLALSimIMRSEOBNRv4ROMTimeOfFrequency(REAL8 *t, REAL8 frequency, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
 int XLALSimIMRSEOBNRv4ROMFrequencyOfTime(REAL8 *frequency, REAL8 t, REAL8 m1SI, REAL8 m2SI, REAL8 chi1, REAL8 chi2);
@@ -433,6 +436,35 @@ int XLALSimIMRPhenomXASFrequencySequence(
   LALDict *lalParams
 );
 
+int XLALSimIMRPhenomXASGenerateFDAmpPhs(REAL8FrequencySeries **wfamplitude,
+  REAL8FrequencySeries **wfphase,
+  REAL8 m1_SI,
+  REAL8 m2_SI,
+  REAL8 chi1L,
+  REAL8 chi2L,
+  REAL8 distance,
+  REAL8 f_min,
+  REAL8 f_max,
+  REAL8 deltaF,
+  REAL8 phiRef,
+  REAL8 fRef_In,
+  LALDict *lalParams
+);
+
+int XLALSimIMRPhenomXASFrequencySequenceAmpPhs(
+  REAL8FrequencySeries **wfamplitude,
+  REAL8FrequencySeries **wfphase,
+  const REAL8Sequence *freqs,
+  REAL8 m1_SI,
+  REAL8 m2_SI,
+  REAL8 chi1L,
+  REAL8 chi2L,
+  REAL8 distance,
+  REAL8 phiRef,
+  REAL8 fRef_In,
+  LALDict *lalParams
+);
+
 int XLALSimIMRPhenomXPMSAAngles(
  REAL8Sequence **alpha_of_f,        /**< [out] The azimuthal angle of L around J */
  REAL8Sequence **gamma_of_f,        /**< [out] The third Euler angle describing L with respect to J. Fixed by minmal rotation condition. */
diff --git a/lalsimulation/lib/LALSimIMRPhenomD.c b/lalsimulation/lib/LALSimIMRPhenomD.c
index 0e6afffb29..3e48e5fd86 100644
--- a/lalsimulation/lib/LALSimIMRPhenomD.c
+++ b/lalsimulation/lib/LALSimIMRPhenomD.c
@@ -1070,3 +1070,447 @@ UNUSED REAL8 IMRPhenomDPhase_OneFrequency(
                               &(pD.phi_prefactors), Rholm, Taulm);
   return phase;
 }
+
+
+
+
+
+
+
+
+
+
+
+
+
+/**Private function to compute the IMRPhenomD amplitude and phase **/
+/** 10 February, 2022, Soumen Roy **/
+
+
+/* *********************************************************************************/
+/* The following private function generates IMRPhenomD frequency-domain Amplitude  */
+/* and phase given coefficients */
+/* *********************************************************************************/
+
+
+
+
+/*
+ * private function prototypes; all internal functions use solar masses.
+ *
+ */
+
+static int IMRPhenomDGenerateFDAmpPhs(
+    REAL8FrequencySeries **wfamplitude, /**< [out] FD amplitude */
+    REAL8FrequencySeries **wfphase,  /**< [out] FD phase */
+    const REAL8Sequence *freqs_in,     /**< Frequency points at which to evaluate the waveform (Hz) */
+    double deltaF,                     /**< If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+                                        * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+                                        * Then we will use deltaF = 0 to create the frequency series we return. */
+    const REAL8 phi0,                  /**< phase at fRef */
+    const REAL8 fRef,                  /**< reference frequency [Hz] */
+    const REAL8 m1_in,                 /**< mass of companion 1 [solar masses] */
+    const REAL8 m2_in,                 /**< mass of companion 2 [solar masses] */
+    const REAL8 chi1_in,               /**< aligned-spin of companion 1 */
+    const REAL8 chi2_in,               /**< aligned-spin of companion 2 */
+    const REAL8 distance,              /**< distance to source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+);
+
+/**
+ * @addtogroup LALSimIMRPhenom_c
+ * @{
+ *
+ * @name Routines for IMR Phenomenological Model "D"
+ * @{
+ *
+ * @author Michael Puerrer, Sebastian Khan, Frank Ohme
+ *
+ * @brief C code for IMRPhenomD phenomenological waveform model.
+ *
+ * This is an aligned-spin frequency domain model.
+ * See Husa et al \cite Husa:2015iqa, and Khan et al \cite Khan:2015jqa
+ * for details. Any studies that use this waveform model should include
+ * a reference to both of these papers.
+ *
+ * @note The model was calibrated to mass-ratios [1:1,1:4,1:8,1:18].
+ * * Along the mass-ratio 1:1 line it was calibrated to spins  [-0.95, +0.98].
+ * * Along the mass-ratio 1:4 line it was calibrated to spins  [-0.75, +0.75].
+ * * Along the mass-ratio 1:8 line it was calibrated to spins  [-0.85, +0.85].
+ * * Along the mass-ratio 1:18 line it was calibrated to spins [-0.8, +0.4].
+ * The calibration points will be given in forthcoming papers.
+ *
+ * @attention The model is usable outside this parameter range,
+ * and in tests to date gives sensible physical results,
+ * but conclusive statements on the physical fidelity of
+ * the model for these parameters await comparisons against further
+ * numerical-relativity simulations. For more information, see the review wiki
+ * under https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview
+ */
+
+
+/**
+ * Driver routine to compute the spin-aligned, inspiral-merger-ringdown
+ * phenomenological waveform IMRPhenomD in the frequency domain.
+ *
+ * Reference:
+ * - Waveform: Eq. 35 and 36 in arXiv:1508.07253
+ * - Coefficients: Eq. 31 and Table V in arXiv:1508.07253
+ *
+ *  All input parameters should be in SI units. Angles should be in radians.
+ *
+ * Compute waveform in LAL format for the IMRPhenomD model.
+ *
+ * Returns the plus and cross polarizations as a complex frequency series with
+ * equal spacing deltaF and contains zeros from zero frequency to the starting
+ * frequency fLow and zeros beyond the cutoff frequency in the ringdown.
+ */
+int XLALSimIMRPhenomDGenerateFDAmpPhs(
+    REAL8FrequencySeries **wfamplitude, /**< [out] FD amplitude */
+    REAL8FrequencySeries **wfphase,  /**< [out] FD phase */
+    const REAL8 phi0,                  /**< Orbital phase at fRef (rad) */
+    const REAL8 fRef_in,               /**< reference frequency (Hz) */
+    const REAL8 deltaF,                /**< Sampling frequency (Hz) */
+    const REAL8 m1_SI,                 /**< Mass of companion 1 (kg) */
+    const REAL8 m2_SI,                 /**< Mass of companion 2 (kg) */
+    const REAL8 chi1,                  /**< Aligned-spin parameter of companion 1 */
+    const REAL8 chi2,                  /**< Aligned-spin parameter of companion 2 */
+    const REAL8 f_min,                 /**< Starting GW frequency (Hz) */
+    const REAL8 f_max,                 /**< End frequency; 0 defaults to Mf = \ref f_CUT */
+    const REAL8 distance,               /**< Distance of source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< Version of NRTides; can be one of NRTidal versions or NoNRT_V for the BBH baseline */
+) {
+  /* external: SI; internal: solar masses */
+  const REAL8 m1 = m1_SI / LAL_MSUN_SI;
+  const REAL8 m2 = m2_SI / LAL_MSUN_SI;
+
+  /* check inputs for sanity */
+  XLAL_CHECK(0 != wfamplitude, XLAL_EFAULT, "wfamplitude is null");
+  if (*wfamplitude) XLAL_ERROR(XLAL_EFAULT);
+  XLAL_CHECK(0 != wfphase, XLAL_EFAULT, "phase is null");
+  if (*wfphase) XLAL_ERROR(XLAL_EFAULT);
+  if (fRef_in < 0) XLAL_ERROR(XLAL_EDOM, "fRef_in must be positive (or 0 for 'ignore')\n");
+  if (deltaF <= 0) XLAL_ERROR(XLAL_EDOM, "deltaF must be positive\n");
+  if (m1 <= 0) XLAL_ERROR(XLAL_EDOM, "m1 must be positive\n");
+  if (m2 <= 0) XLAL_ERROR(XLAL_EDOM, "m2 must be positive\n");
+  if (f_min <= 0) XLAL_ERROR(XLAL_EDOM, "f_min must be positive\n");
+  if (f_max < 0) XLAL_ERROR(XLAL_EDOM, "f_max must be greater than 0\n");
+  if (distance <= 0) XLAL_ERROR(XLAL_EDOM, "distance must be positive\n");
+
+  const REAL8 q = (m1 > m2) ? (m1 / m2) : (m2 / m1);
+
+  if (q > MAX_ALLOWED_MASS_RATIO)
+    XLAL_PRINT_WARNING("Warning: The model is not supported for high mass ratio, see MAX_ALLOWED_MASS_RATIO\n");
+
+  if (chi1 > 1.0 || chi1 < -1.0 || chi2 > 1.0 || chi2 < -1.0)
+    XLAL_ERROR(XLAL_EDOM, "Spins outside the range [-1,1] are not supported\n");
+
+  // if no reference frequency given, set it to the starting GW frequency
+  REAL8 fRef = (fRef_in == 0.0) ? f_min : fRef_in;
+
+  const REAL8 M_sec = (m1+m2) * LAL_MTSUN_SI; // Conversion factor Hz -> dimensionless frequency
+  const REAL8 fCut = f_CUT/M_sec; // convert Mf -> Hz
+  // Somewhat arbitrary end point for the waveform.
+  // Chosen so that the end of the waveform is well after the ringdown.
+  if (fCut <= f_min)
+    XLAL_ERROR(XLAL_EDOM, "(fCut = %g Hz) <= f_min = %g\n", fCut, f_min);
+
+    /* default f_max to Cut */
+  REAL8 f_max_prime = f_max;
+  f_max_prime = f_max ? f_max : fCut;
+  f_max_prime = (f_max_prime > fCut) ? fCut : f_max_prime;
+  if (f_max_prime <= f_min)
+    XLAL_ERROR(XLAL_EDOM, "f_max <= f_min\n");
+
+  // Use fLow, fHigh, deltaF to compute freqs sequence
+  // Instead of building a full sequency we only transfer the boundaries and let
+  // the internal core function do the rest (and properly take care of corner cases).
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = f_min;
+  freqs->data[1] = f_max_prime;
+  int status = IMRPhenomDGenerateFDAmpPhs(wfamplitude, wfphase, freqs, deltaF, phi0, fRef,
+                                    m1, m2, chi1, chi2,
+                                    distance, extraParams, NRTidal_version);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to generate IMRPhenomD waveform.");
+  XLALDestroyREAL8Sequence(freqs);
+
+  if (f_max_prime < f_max) {
+    // The user has requested a higher f_max than Mf=fCut.
+    // Resize the frequency series to fill with zeros beyond the cutoff frequency.
+      
+    size_t n = (*wfamplitude)->data->length;
+    size_t n_full = NextPow2(f_max / deltaF) + 1; // we actually want to have the length be a power of 2 + 1
+    *wfamplitude = XLALResizeREAL8FrequencySeries(*wfamplitude, 0, n_full);
+    *wfphase = XLALResizeREAL8FrequencySeries(*wfphase, 0, n_full);
+    XLAL_CHECK ( *wfamplitude, XLAL_ENOMEM, "Failed to resize waveform COMPLEX16FrequencySeries of length %zu (for internal fCut=%f) to new length %zu (for user-requested f_max=%f).", n, fCut, n_full, f_max );
+    XLAL_CHECK ( *wfphase, XLAL_ENOMEM, "Failed to resize waveform COMPLEX16FrequencySeries of length %zu (for internal fCut=%f) to new length %zu (for user-requested f_max=%f).", n, fCut, n_full, f_max );
+  }
+
+  return XLAL_SUCCESS;
+}
+
+
+
+
+/** @} */
+
+/** @} */
+
+/* *********************************************************************************/
+/* The following private function generates IMRPhenomD frequency-domain waveforms  */
+/* given coefficients */
+/* *********************************************************************************/
+
+static int IMRPhenomDGenerateFDAmpPhs(
+    REAL8FrequencySeries **wfamplitude, /**< [out] FD amplitude */
+    REAL8FrequencySeries **wfphase,  /**< [out] FD phase */
+    const REAL8Sequence *freqs_in,     /**< Frequency points at which to evaluate the waveform (Hz) */
+    double deltaF,                     /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+                                        * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+                                        * Then we will use deltaF = 0 to create the frequency series we return. */
+    const REAL8 phi0,                  /**< phase at fRef */
+    const REAL8 fRef,                  /**< reference frequency [Hz] */
+    const REAL8 m1_in,                 /**< mass of companion 1 [solar masses] */
+    const REAL8 m2_in,                 /**< mass of companion 2 [solar masses] */
+    const REAL8 chi1_in,               /**< aligned-spin of companion 1 */
+    const REAL8 chi2_in,               /**< aligned-spin of companion 2 */
+    const REAL8 distance,              /**< distance to source (m) */
+    LALDict *extraParams, /**< linked list containing the extra testing GR parameters */
+    NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+) {
+  LIGOTimeGPS ligotimegps_zero = LIGOTIMEGPSZERO; // = {0, 0}
+
+  // Make a pointer to LALDict to circumvent a memory leak
+  // At the end we will check if we created a LALDict in extraParams
+  // and destroy it if we did.
+  LALDict *extraParams_in = extraParams;
+  REAL8Sequence *amp_tidal = NULL; /* Tidal amplitude series; required only for IMRPhenomD_NRTidalv2 */
+  REAL8 dquadmon1_in = 0., dquadmon2_in = 0., lambda1_in = 0, lambda2_in = 0.;
+  if (NRTidal_version == NRTidalv2_V) {
+    dquadmon1_in = XLALSimInspiralWaveformParamsLookupdQuadMon1(extraParams);
+    dquadmon2_in = XLALSimInspiralWaveformParamsLookupdQuadMon2(extraParams);
+    lambda1_in = XLALSimInspiralWaveformParamsLookupTidalLambda1(extraParams);
+    lambda2_in = XLALSimInspiralWaveformParamsLookupTidalLambda2(extraParams);
+  }
+
+  REAL8 chi1, chi2, m1, m2, dquadmon1, dquadmon2, lambda1, lambda2;
+  if (m1_in>=m2_in) {
+     chi1 = chi1_in;
+     chi2 = chi2_in;
+     m1   = m1_in;
+     m2   = m2_in;
+     dquadmon1 = dquadmon1_in;
+     dquadmon2 = dquadmon2_in;
+     lambda1 = lambda1_in;
+     lambda2 = lambda2_in;
+  } else { // swap spins and masses
+     chi1 = chi2_in;
+     chi2 = chi1_in;
+     m1   = m2_in;
+     m2   = m1_in;
+     dquadmon1 = dquadmon2_in;
+     dquadmon2 = dquadmon1_in;
+     lambda1 = lambda2_in;
+     lambda2 = lambda1_in;
+     if (NRTidal_version == NRTidalv2_V) {
+       XLALSimInspiralWaveformParamsInsertdQuadMon1(extraParams, dquadmon1);
+       XLALSimInspiralWaveformParamsInsertdQuadMon2(extraParams, dquadmon2);
+     }
+  }
+
+  int status = init_useful_powers(&powers_of_pi, LAL_PI);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initiate useful powers of pi.");
+
+  /* Find frequency bounds */
+  if (!freqs_in || !freqs_in->data) XLAL_ERROR(XLAL_EFAULT);
+  double f_min = freqs_in->data[0];
+  double f_max = freqs_in->data[freqs_in->length - 1];
+  XLAL_CHECK(f_min > 0, XLAL_EDOM, "Minimum frequency must be positive.\n");
+  XLAL_CHECK(f_max >= 0, XLAL_EDOM, "Maximum frequency must be non-negative.\n");
+
+  const REAL8 M = m1 + m2;
+  REAL8 eta = m1 * m2 / (M * M);
+
+  if (eta > 0.25)
+      PhenomInternal_nudge(&eta, 0.25, 1e-6);
+  if (eta > 0.25 || eta < 0.0)
+      XLAL_ERROR(XLAL_EDOM, "Unphysical eta. Must be between 0. and 0.25\n");
+
+  const REAL8 M_sec = M * LAL_MTSUN_SI;
+
+  /* Compute the amplitude pre-factor */
+  const REAL8 amp0 = 2. * sqrt(5. / (64.*LAL_PI)) * M * LAL_MRSUN_SI * M * LAL_MTSUN_SI / distance;
+
+  size_t npts = 0;
+  UINT4 offset = 0; // Index shift between freqs and the frequency series
+  REAL8Sequence *freqs = NULL;
+  if (deltaF > 0)  { // freqs contains uniform frequency grid with spacing deltaF; we start at frequency 0
+    /* Set up output array with size closest power of 2 */
+    npts = NextPow2(f_max / deltaF) + 1;
+    /* Coalesce at t=0 */
+    // shift by overall length in time
+    XLAL_CHECK ( XLALGPSAdd(&ligotimegps_zero, -1. / deltaF), XLAL_EFUNC, "Failed to shift coalescence time to t=0, tried to apply shift of -1.0/deltaF with deltaF=%g.", deltaF);
+    *wfamplitude = XLALCreateREAL8FrequencySeries("amplitude: FD waveform", &ligotimegps_zero, 0.0, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *wfamplitude, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu for f_max=%f, deltaF=%g.", npts, f_max, deltaF);
+    *wfphase = XLALCreateREAL8FrequencySeries("phase: FD waveform", &ligotimegps_zero, 0.0, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *wfphase, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu for f_max=%f, deltaF=%g.", npts, f_max, deltaF);
+    // Recreate freqs using only the lower and upper bounds
+    size_t iStart = (size_t) (f_min / deltaF);
+    size_t iStop = (size_t) (f_max / deltaF);
+    XLAL_CHECK ( (iStop<=npts) && (iStart<=iStop), XLAL_EDOM, "minimum freq index %zu and maximum freq index %zu do not fulfill 0<=ind_min<=ind_max<=htilde->data>length=%zu.", iStart, iStop, npts);
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    if (!freqs)
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    for (UINT4 i=iStart; i<iStop; i++)
+      freqs->data[i-iStart] = i*deltaF;
+    offset = iStart;
+  } else { // freqs contains frequencies with non-uniform spacing; we start at lowest given frequency
+    npts = freqs_in->length;
+    *wfamplitude = XLALCreateREAL8FrequencySeries("amplitude: FD waveform", &ligotimegps_zero, f_min, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *wfamplitude, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu from sequence.", npts);
+    *wfphase = XLALCreateREAL8FrequencySeries("phase: FD waveform", &ligotimegps_zero, f_min, deltaF, &lalStrainUnit, npts);
+    XLAL_CHECK ( *wfphase, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu from sequence.", npts);
+    offset = 0;
+    freqs = XLALCreateREAL8Sequence(freqs_in->length);
+    if (!freqs)
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    for (UINT4 i=0; i<freqs_in->length; i++)
+      freqs->data[i] = freqs_in->data[i];
+  }
+
+  memset((*wfamplitude)->data->data, 0, npts * sizeof(REAL8));
+  XLALUnitMultiply(&((*wfamplitude)->sampleUnits), &((*wfamplitude)->sampleUnits), &lalSecondUnit);
+  
+  memset((*wfphase)->data->data, 0, npts * sizeof(REAL8));
+  XLALUnitMultiply(&((*wfphase)->sampleUnits), &((*wfphase)->sampleUnits), &lalSecondUnit);
+
+  // Calculate phenomenological parameters
+  const REAL8 finspin = FinalSpin0815(eta, chi1, chi2); //FinalSpin0815 - 0815 is like a version number
+
+  if (finspin < MIN_FINAL_SPIN)
+          XLAL_PRINT_WARNING("Final spin (Mf=%g) and ISCO frequency of this system are small, \
+                          the model might misbehave here.", finspin);
+
+  IMRPhenomDAmplitudeCoefficients *pAmp;
+  pAmp = XLALMalloc(sizeof(IMRPhenomDAmplitudeCoefficients));
+  ComputeIMRPhenomDAmplitudeCoefficients(pAmp, eta, chi1, chi2, finspin);
+  if (!pAmp) XLAL_ERROR(XLAL_EFUNC);
+  if (extraParams==NULL)
+    extraParams=XLALCreateDict();
+  XLALSimInspiralWaveformParamsInsertPNSpinOrder(extraParams,LAL_SIM_INSPIRAL_SPIN_ORDER_35PN);
+  IMRPhenomDPhaseCoefficients *pPhi;
+  pPhi = XLALMalloc(sizeof(IMRPhenomDPhaseCoefficients));
+  ComputeIMRPhenomDPhaseCoefficients(pPhi, eta, chi1, chi2, finspin, extraParams);
+  if (!pPhi) XLAL_ERROR(XLAL_EFUNC);
+  PNPhasingSeries *pn = NULL;
+  XLALSimInspiralTaylorF2AlignedPhasing(&pn, m1, m2, chi1, chi2, extraParams);
+  if (!pn) XLAL_ERROR(XLAL_EFUNC);
+
+  // Subtract 3PN spin-spin term below as this is in LAL's TaylorF2 implementation
+  // (LALSimInspiralPNCoefficients.c -> XLALSimInspiralPNPhasing_F2), but
+  REAL8 testGRcor=1.0;
+  testGRcor += XLALSimInspiralWaveformParamsLookupNonGRDChi6(extraParams);
+
+  // was not available when PhenomD was tuned.
+  pn->v[6] -= (Subtract3PNSS(m1, m2, M, eta, chi1, chi2) * pn->v[0]) * testGRcor;
+
+  PhiInsPrefactors phi_prefactors;
+  status = init_phi_ins_prefactors(&phi_prefactors, pPhi, pn);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_phi_ins_prefactors failed");
+
+  // Compute coefficients to make phase C^1 continuous (phase and first derivative)
+  ComputeIMRPhenDPhaseConnectionCoefficients(pPhi, pn, &phi_prefactors, 1.0, 1.0);
+
+  //time shift so that peak amplitude is approximately at t=0
+  //For details see https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/WaveformsReview/IMRPhenomDCodeReview/timedomain
+  const REAL8 t0 = DPhiMRD(pAmp->fmaxCalc, pPhi, 1.0, 1.0);
+
+  AmpInsPrefactors amp_prefactors;
+  status = init_amp_ins_prefactors(&amp_prefactors, pAmp);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_amp_ins_prefactors failed");
+
+  // incorporating fRef
+  const REAL8 MfRef = M_sec * fRef;
+  UsefulPowers powers_of_fRef;
+  status = init_useful_powers(&powers_of_fRef, MfRef);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "init_useful_powers failed for MfRef");
+  const REAL8 phifRef = IMRPhenDPhase(MfRef, pPhi, pn, &powers_of_fRef, &phi_prefactors, 1.0, 1.0);
+
+  // factor of 2 b/c phi0 is orbital phase
+  const REAL8 phi_precalc = 2.*phi0 + phifRef;
+
+  int status_in_for = XLAL_SUCCESS;
+  int ret = XLAL_SUCCESS;
+  /* Now generate the waveform */
+  if (NRTidal_version == NRTidalv2_V) {
+    /* Generate the tidal amplitude (Eq. 24 of arxiv: 1905.06011) to add to BBH baseline; only for IMRPhenomD_NRTidalv2 */
+    amp_tidal = XLALCreateREAL8Sequence(freqs->length);
+    ret = XLALSimNRTunedTidesFDTidalAmplitudeFrequencySeries(amp_tidal, freqs, m1, m2, lambda1, lambda2);
+    XLAL_CHECK(XLAL_SUCCESS == ret, ret, "Failed to generate tidal amplitude series to construct IMRPhenomD_NRTidalv2 waveform.");
+    /* Generated tidal amplitude corrections */
+    #pragma omp parallel for
+    for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double Mf = M_sec * freqs->data[i];
+      double ampT = amp_tidal->data[i];
+      int j = i + offset; // shift index for frequency series if needed
+
+      UsefulPowers powers_of_f;
+      status_in_for = init_useful_powers(&powers_of_f, Mf);
+      if (XLAL_SUCCESS != status_in_for)
+      {
+        XLALPrintError("init_useful_powers failed for Mf, status_in_for=%d", status_in_for);
+        status = status_in_for;
+      }
+      else {
+        REAL8 amp = IMRPhenDAmplitude(Mf, pAmp, &powers_of_f, &amp_prefactors);
+        REAL8 phi = IMRPhenDPhase(Mf, pPhi, pn, &powers_of_f, &phi_prefactors, 1.0, 1.0);
+
+        phi -= t0*(Mf-MfRef) + phi_precalc;
+        ((*wfamplitude)->data->data)[j] =  amp0 * (amp+2*sqrt(LAL_PI/5.)*ampT)  ;
+        ((*wfphase)->data->data)[j] = phi ;
+      }
+    }
+  } else {
+      #pragma omp parallel for
+      for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double Mf = M_sec * freqs->data[i];
+      int j = i + offset; // shift index for frequency series if needed
+
+      UsefulPowers powers_of_f;
+      status_in_for = init_useful_powers(&powers_of_f, Mf);
+      if (XLAL_SUCCESS != status_in_for)
+      {
+        XLALPrintError("init_useful_powers failed for Mf, status_in_for=%d", status_in_for);
+        status = status_in_for;
+      }
+      else {
+        REAL8 amp = IMRPhenDAmplitude(Mf, pAmp, &powers_of_f, &amp_prefactors);
+        REAL8 phi = IMRPhenDPhase(Mf, pPhi, pn, &powers_of_f, &phi_prefactors, 1.0, 1.0);
+        
+        phi -= t0*(Mf-MfRef) + phi_precalc;
+        ((*wfamplitude)->data->data)[j] = amp0 * amp ;
+        ((*wfphase)->data->data)[j] = phi ;
+      }
+    }
+  }
+
+  LALFree(pAmp);
+  LALFree(pPhi);
+  LALFree(pn);
+  XLALDestroyREAL8Sequence(freqs);
+  XLALDestroyREAL8Sequence(amp_tidal);
+
+
+  /* If extraParams was allocated in this function and not passed in
+   * we need to free it to prevent a leak */
+  if (extraParams && !extraParams_in) {
+    XLALDestroyDict(extraParams);
+  } else {
+    XLALSimInspiralWaveformParamsInsertPNSpinOrder(extraParams,LAL_SIM_INSPIRAL_SPIN_ORDER_ALL);
+  }
+
+  return status;
+}
+
diff --git a/lalsimulation/lib/LALSimIMRPhenomX.c b/lalsimulation/lib/LALSimIMRPhenomX.c
index 81333ef8c4..26eeafca5b 100644
--- a/lalsimulation/lib/LALSimIMRPhenomX.c
+++ b/lalsimulation/lib/LALSimIMRPhenomX.c
@@ -1832,3 +1832,565 @@ int IMRPhenomXPGenerateFD(
 
   return status;
 }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/************ Soumen's modification ********************/
+
+
+/**
+ *  Driver routine to calculate an IMRPhenomX aligned-spin,
+ *  inspiral-merger-ringdown phenomenological waveform model
+ *  in the frequency domain.
+ *
+ *  arXiv:2001.11412, https://arxiv.org/abs/2001.11412
+ *
+ *  All input parameters should be in SI units. Angles should be in radians.
+ *
+ *  XLALSimIMRPhenomXASGenerateFD() returns the strain of the 2-2 mode as a complex
+ * frequency series with equal spacing deltaF and contains zeros from zero frequency
+ * to the starting frequency and zeros beyond the cutoff frequency in the ringdown.
+ *
+ */
+int XLALSimIMRPhenomXASGenerateFDAmpPhs(
+  REAL8FrequencySeries **wfamplitude,  /**< [out] FD waveform */
+  REAL8FrequencySeries **wfphase,      /**< [out] FD waveform */
+  REAL8 m1_SI,                         /**< Mass of companion 1 (kg) */
+  REAL8 m2_SI,                         /**< Mass of companion 2 (kg) */
+  REAL8 chi1L,                         /**< Dimensionless aligned spin of companion 1 */
+  REAL8 chi2L,                         /**< Dimensionless aligned spin of companion 2 */
+  REAL8 distance,                      /**< Luminosity distance (m) */
+  REAL8 f_min,                         /**< Starting GW frequency (Hz) */
+  REAL8 f_max,                         /**< End frequency; 0 defaults to Mf = 0.3 */
+  REAL8 deltaF,                        /**< Sampling frequency (Hz) */
+  REAL8 phi0,                          /**< Orbital phase at fRef (rad) */
+  REAL8 fRef_In,                       /**< Reference frequency (Hz) */
+  LALDict *lalParams                   /**< LAL Dictionary */
+)
+{
+  UINT4 status;
+
+  /* Set debug status here */
+  UINT4 debug = PHENOMXDEBUG;
+
+  if(debug)
+  {
+    printf("fRef_In : %e\n",fRef_In);
+    printf("m1_SI   : %e\n",m1_SI);
+    printf("m2_SI   : %e\n",m2_SI);
+    printf("chi1L   : %e\n",chi1L);
+    printf("chi2L   : %e\n\n",chi2L);
+    printf("Performing sanity checks...\n");
+  }
+
+  /* Perform initial sanity checks */
+  if(*wfamplitude)       { XLAL_CHECK(NULL != wfamplitude, XLAL_EFAULT);                                }
+  if(*wfphase)       { XLAL_CHECK(NULL != wfphase, XLAL_EFAULT);                                    }
+  if(fRef_In  <  0.0) { XLAL_ERROR(XLAL_EDOM, "fRef_In must be positive or set to 0 to ignore.\n");  }
+  if(deltaF   <= 0.0) { XLAL_ERROR(XLAL_EDOM, "deltaF must be positive.\n");                         }
+  if(m1_SI    <= 0.0) { XLAL_ERROR(XLAL_EDOM, "m1 must be positive.\n");                             }
+  if(m2_SI    <= 0.0) { XLAL_ERROR(XLAL_EDOM, "m2 must be positive.\n");                             }
+  if(f_min    <= 0.0) { XLAL_ERROR(XLAL_EDOM, "f_min must be positive.\n");                          }
+  if(f_max    <  0.0) { XLAL_ERROR(XLAL_EDOM, "f_max must be non-negative.\n");                      }
+  if(distance <  0.0) { XLAL_ERROR(XLAL_EDOM, "Distance must be positive and greater than 0.\n");    }
+
+  /*
+  	Perform a basic sanity check on the region of the parameter space in which model is evaluated. Behaviour is as follows:
+  		- For mass ratios <= 20.0 and spins <= 0.99: no warning messages.
+  		- For 1000 > mass ratio > 20 and spins <= 0.99: print a warning message that we are extrapolating outside of *NR* calibration domain.
+  		- For mass ratios > 1000: throw a hard error that model is not valid.
+  		- For spins > 0.99: throw a warning that we are extrapolating the model to extremal
+
+  */
+  REAL8 mass_ratio;
+  if(m1_SI > m2_SI)
+  {
+	  mass_ratio = m1_SI / m2_SI;
+  }
+  else
+  {
+	  mass_ratio = m2_SI / m1_SI;
+  }
+  if(mass_ratio > 20.0  ) { XLAL_PRINT_INFO("Warning: Extrapolating outside of Numerical Relativity calibration domain."); }
+  if(mass_ratio > 1000. && fabs(mass_ratio - 1000) > 1e-12) { XLAL_ERROR(XLAL_EDOM, "ERROR: Model not valid at mass ratios beyond 1000."); } // The 1e-12 is to avoid rounding errors
+  if(fabs(chi1L) > 0.99 || fabs(chi2L) > 0.99) { XLAL_PRINT_INFO("Warning: Extrapolating to extremal spins, model is not trusted."); }
+
+  /* If no reference frequency is given, set it to the starting gravitational wave frequency */
+  REAL8 fRef = (fRef_In == 0.0) ? f_min : fRef_In;
+
+
+  if(debug)
+  {
+    printf("\n\n **** Initializing waveform struct... **** \n\n");
+  }
+
+
+  /* Initialize the useful powers of LAL_PI */
+  status = IMRPhenomX_Initialize_Powers(&powers_of_lalpi, LAL_PI);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initialize useful powers of LAL_PI.");
+
+  /* Initialize IMR PhenomX Waveform struct and check that it initialized correctly */
+  IMRPhenomXWaveformStruct *pWF;
+  pWF    = XLALMalloc(sizeof(IMRPhenomXWaveformStruct));
+  status = IMRPhenomXSetWaveformVariables(pWF, m1_SI, m2_SI, chi1L, chi2L, deltaF, fRef, phi0, f_min, f_max, distance, 0.0, lalParams, debug);
+  XLAL_CHECK(XLAL_SUCCESS == status, XLAL_EFUNC, "Error: IMRPhenomXSetWaveformVariables failed.\n");
+
+  /*
+      Create a REAL8 frequency series.
+      Use fLow, fHigh, deltaF to compute frequency sequence. Only pass the boundaries (fMin, fMax).
+  */
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = pWF->fMin;
+  freqs->data[1] = pWF->f_max_prime;
+
+
+  if(debug)
+  {
+    printf("\n\n **** Calling IMRPhenomXASGenerateFD... **** \n\n");
+  }
+
+  /* We now call the core IMRPhenomXAS waveform generator */
+  status = IMRPhenomXASGenerateFDAmpPhs(wfamplitude, wfphase, freqs, pWF, lalParams);
+  XLAL_CHECK(status == XLAL_SUCCESS, XLAL_EFUNC, "IMRPhenomXASFDCore failed to generate IMRPhenomX waveform.");
+
+  if(debug)
+  {
+    printf("\n\n **** Call to IMRPhenomXASGenerateFD complete. **** \n\n");
+  }
+
+  /*
+      We now resize htilde22 if our waveform was generated to a cut-off frequency below
+      the desired maximum frequency. Simply fill the remaining frequencies with zeros.
+  */
+  REAL8 lastfreq;
+  if (pWF->f_max_prime < pWF->fMax)
+  {
+    /*
+        As the user has requested an f_max > Mf = fCut,
+        we resize the frequency series to fill with zeros beyond the cutoff frequency.
+    */
+    lastfreq = pWF->fMax;
+  }
+  else{  // We have to look for a power of 2 anyway.
+    lastfreq = pWF->f_max_prime;
+  }
+  /* Enforce length to be a power of 2 + 1 */
+  size_t n_full = NextPow2(lastfreq / pWF->deltaF) + 1;
+  size_t n = (*wfamplitude)->data->length;
+
+  /* Resize the REAL8 frequency series */
+  *wfamplitude = XLALResizeREAL8FrequencySeries(*wfamplitude, 0, n_full);
+  *wfphase = XLALResizeREAL8FrequencySeries(*wfphase, 0, n_full);
+  XLAL_CHECK (*wfamplitude, XLAL_ENOMEM, "Failed to resize waveform COMPLEX16FrequencySeries of length %zu (for internal fCut=%f) to new length %zu (for user-requested f_max=%f).", n, pWF->fCut, n_full, pWF->fMax );
+
+
+  LALFree(pWF);
+  XLALDestroyREAL8Sequence(freqs);
+  return XLAL_SUCCESS;
+}
+
+
+/**
+ * Compute waveform in LAL format at specified frequencies for the IMRPhenomX model.
+ *
+ *  All input parameters should be in SI units. Angles should be in radians.
+ *
+ * XLALSimIMRPhenomXASFrequencySequence() returns the strain of the 2-2 mode as a
+ * complex frequency series with entries exactly at the frequencies specified in
+ * the sequence freqs (which can be unequally spaced). No zeros are added. Assumes positive frequencies.
+ */
+ int XLALSimIMRPhenomXASFrequencySequenceAmpPhs(
+     REAL8FrequencySeries **wfamplitude, /**< [out] FD waveform */
+     REAL8FrequencySeries **wfphase, /**< [out] FD waveform */
+     const REAL8Sequence *freqs,          /**< [out] Frequency series [Hz] */
+     REAL8 m1_SI,                         /**< Mass of companion 1 (kg) */
+     REAL8 m2_SI,                         /**< Mass of companion 2 (kg) */
+     REAL8 chi1L,                         /**< Dimensionless aligned spin of companion 1 */
+     REAL8 chi2L,                         /**< Dimensionless aligned spin of companion 2 */
+     REAL8 distance,                      /**< Luminosity distance (m) */
+     REAL8 phi0,                          /**< Phase at reference frequency */
+     REAL8 fRef_In,                       /**< Reference frequency (Hz) */
+     LALDict *lalParams                   /**< LAL Dictionary */
+ )
+ {
+   INT4 return_code = 0;
+
+   /* Sanity checks */
+   if(*wfamplitude)       { XLAL_CHECK(NULL != wfamplitude, XLAL_EFAULT);                                   }
+   if(*wfphase)       { XLAL_CHECK(NULL != wfphase, XLAL_EFAULT);                                 }
+   if(fRef_In  <  0.0) { XLAL_ERROR(XLAL_EDOM, "fRef_In must be positive or set to 0 to ignore.\n");  }
+   if(m1_SI    <= 0.0) { XLAL_ERROR(XLAL_EDOM, "m1 must be positive.\n");                             }
+   if(m2_SI    <= 0.0) { XLAL_ERROR(XLAL_EDOM, "m2 must be positive.\n");                             }
+   if(distance <  0.0) { XLAL_ERROR(XLAL_EDOM, "Distance must be positive and greater than 0.\n");    }
+
+   /*
+	Perform a basic sanity check on the region of the parameter space in which model is evaluated. Behaviour is as follows:
+		- For mass ratios <= 20.0 and spins <= 0.99: no warning messages.
+		- For 1000 > mass ratio > 20 and spins <= 0.99: print a warning message that we are extrapolating outside of *NR* calibration domain.
+		- For mass ratios > 1000: throw a hard error that model is not valid.
+		- For spins > 0.99: throw a warning that we are extrapolating the model to extremal
+
+   */
+   REAL8 mass_ratio;
+   if(m1_SI > m2_SI)
+   {
+	mass_ratio = m1_SI / m2_SI;
+   }
+   else
+   {
+	mass_ratio = m2_SI / m1_SI;
+   }
+   if(mass_ratio > 20.0  ) { XLAL_PRINT_INFO("Warning: Extrapolating outside of Numerical Relativity calibration domain."); }
+
+   // Check on the mass-ratio with a 1e-12 tolerance to avoid rounding errors
+   if(mass_ratio > 1000. && fabs(mass_ratio - 1000) > 1e-12) { XLAL_ERROR(XLAL_EDOM, "ERROR: Model not valid at mass ratios beyond 1000."); }
+   if(fabs(chi1L) > 0.99 || fabs(chi2L) > 0.99) { XLAL_PRINT_INFO("Warning: Extrapolating to extremal spins, model is not trusted."); }
+
+   // If fRef is not provided, then set fRef to be the starting GW Frequency
+   REAL8 fRef = (fRef_In == 0.0) ? freqs->data[0] : fRef_In;
+
+   UINT4 status = IMRPhenomX_Initialize_Powers(&powers_of_lalpi, LAL_PI);
+   XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initialize useful powers of LAL_PI.");
+
+   /*
+      This routine automatically performs sanity checks on the masses, spins, etc.
+   */
+   REAL8 f_min_In  = freqs->data[0];
+   REAL8 f_max_In  = freqs->data[freqs->length - 1];
+
+   /*
+      Passing deltaF = 0 implies that freqs is a frequency grid with non-uniform spacing.
+      The function waveform then start at lowest given frequency.
+   */
+
+   /* Initialize IMRPhenomX waveform struct and perform sanity check. */
+   IMRPhenomXWaveformStruct *pWF;
+   pWF = XLALMalloc(sizeof(IMRPhenomXWaveformStruct));
+   return_code = IMRPhenomXSetWaveformVariables(pWF,m1_SI, m2_SI, chi1L, chi2L, 0.0, fRef, phi0, f_min_In, f_max_In, distance, 0.0, lalParams, 0);
+   XLAL_CHECK(XLAL_SUCCESS == return_code, XLAL_EFUNC, "Error: IMRPhenomXSetWaveformVariables failed.\n");
+
+   /* Now call the core IMRPhenomX waveform generator */
+   return_code = IMRPhenomXASGenerateFDAmpPhs(
+     wfamplitude,
+     wfphase,
+     freqs,
+     pWF,
+     lalParams
+   );
+   XLAL_CHECK(return_code == XLAL_SUCCESS, XLAL_EFUNC, "IMRPhenomXASFDCore failed to generate IMRPhenomX waveform.");
+   LALFree(pWF);
+
+   return XLAL_SUCCESS;
+ }
+
+ /** @} */
+ /** @} */
+
+
+ /* *********************************************************************************
+  *
+  * The following private function generates an IMRPhenomX frequency-domain waveform
+  *   - Only aligned-spin
+  *   - Only the 22-mode
+  *   - Physical parameters are passed via the waveform struct
+  * *********************************************************************************
+  */
+int IMRPhenomXASGenerateFDAmpPhs(
+  REAL8FrequencySeries **wfamplitude, /**< [out] FD waveform           */
+  REAL8FrequencySeries **wfphase, /**< [out] FD waveform           */
+  const REAL8Sequence *freqs_In,       /**< Input frequency grid        */
+  IMRPhenomXWaveformStruct *pWF,       /**< IMRPhenomX Waveform Struct  */
+  LALDict *lalParams                   /**< LAL Dictionary Structure    */
+)
+{
+  /* Inherits debug flag from waveform struct */
+  UINT4 debug = PHENOMXDEBUG;
+
+  if(debug)
+  {
+    printf("\n **** Now in IMRPhenomXASGenerateFD... **** \n");
+  }
+
+  /* Set LIGOTimeGPS */
+  LIGOTimeGPS ligotimegps_zero = LIGOTIMEGPSZERO; // = {0,0}
+
+  /* Initialize useful powers of LAL_PI */
+  int status = IMRPhenomX_Initialize_Powers(&powers_of_lalpi, LAL_PI);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "Failed to initialize useful powers of LAL_PI.");
+
+  /* Inherit minimum and maximum frequencies to generate wavefom from input frequency grid */
+  double f_min = freqs_In->data[0];
+  double f_max = freqs_In->data[freqs_In->length - 1];
+
+  /* Size of array */
+  size_t npts     = 0;
+
+  /* Index shift between freqs and the frequency series */
+  UINT4 offset    = 0;
+
+  /* Initialize frequency sequence */
+  REAL8Sequence *freqs = NULL;
+
+  /* If deltaF is non-zero then we need to generate a uniformly sampled frequency grid of spacing deltaF. Start at f = 0. */
+  if(pWF->deltaF > 0)
+  {
+    /* Return the closest power of 2 */
+    npts = (size_t) (f_max/pWF->deltaF) + 1;
+
+    /* Debug information */
+    if(debug)
+    {
+      printf("npts     = %zu\n",npts);
+      printf("fMin     = %.4f\n",f_min);
+      printf("fMax     = %.4f\n",f_max);
+      printf("dF       = %.4f\n",pWF->deltaF);
+    }
+
+    XLAL_CHECK(XLALGPSAdd(&ligotimegps_zero, -1. / pWF->deltaF ), XLAL_EFUNC, "Failed to shift the coalescence time to t=0. Tried to apply a shift of -1/df with df = %g.", pWF->deltaF);
+
+    /* Initialize the htilde frequency series */
+    *wfamplitude = XLALCreateREAL8FrequencySeries("htilde22: FD waveform",&ligotimegps_zero,0.0,pWF->deltaF,&lalStrainUnit,npts);
+
+    /* Check that frequency series generated okay */
+    XLAL_CHECK(*wfamplitude,XLAL_ENOMEM,"Failed to allocate COMPLEX16FrequencySeries of length %zu for f_max = %f, deltaF = %g.\n",npts,f_max,pWF->deltaF);
+      
+    /* Initialize the htilde frequency series */
+    *wfphase = XLALCreateREAL8FrequencySeries("htilde22: FD waveform",&ligotimegps_zero,0.0,pWF->deltaF,&lalStrainUnit,npts);
+
+    /* Check that frequency series generated okay */
+    XLAL_CHECK(*wfphase,XLAL_ENOMEM,"Failed to allocate COMPLEX16FrequencySeries of length %zu for f_max = %f, deltaF = %g.\n",npts,f_max,pWF->deltaF);
+
+    /* Frequencies will be set using only the lower and upper bounds that we passed */
+    size_t iStart = (size_t) (f_min / pWF->deltaF);
+    size_t iStop  = (size_t) (f_max / pWF->deltaF) + 1;
+
+    XLAL_CHECK ( (iStop <= npts) && (iStart <= iStop), XLAL_EDOM,
+          "minimum freq index %zu and maximum freq index %zu do not fulfill 0<=ind_min<=ind_max<=htilde->data>length=%zu.", iStart, iStop, npts);
+
+    /* Allocate memory for frequency array and terminate if this fails */
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    if (!freqs)
+    {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+
+    /* Populate frequency array */
+    for (UINT4 i = iStart; i < iStop; i++)
+    {
+      freqs->data[i-iStart] = i * pWF->deltaF;
+    }
+    offset = iStart;
+  }
+  else
+  {
+    /* freqs is a frequency grid with non-uniform spacing, so we start at the lowest given frequency */
+    npts      = freqs_In->length;
+    *wfamplitude = XLALCreateREAL8FrequencySeries("htilde22: FD waveform, 22 mode", &ligotimegps_zero, f_min, pWF->deltaF, &lalStrainUnit, npts);
+
+    XLAL_CHECK (*wfamplitude, XLAL_ENOMEM, "Failed to allocated waveform COMPLEX16FrequencySeries of length %zu from sequence.", npts);
+
+    offset = 0;
+    freqs  = XLALCreateREAL8Sequence(freqs_In->length);
+
+    /* Allocate memory for frequency array and terminate if this fails */
+    if (!freqs)
+    {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+
+    /* Populate frequency array */
+    for (UINT4 i = 0; i < freqs_In->length; i++)
+    {
+      freqs->data[i] = freqs_In->data[i];
+    }
+  }
+
+  memset((*wfamplitude)->data->data, 0, npts * sizeof(REAL8));
+  XLALUnitMultiply(&((*wfamplitude)->sampleUnits), &((*wfamplitude)->sampleUnits), &lalSecondUnit);
+    
+  memset((*wfphase)->data->data, 0, npts * sizeof(REAL8));
+  XLALUnitMultiply(&((*wfphase)->sampleUnits), &((*wfphase)->sampleUnits), &lalSecondUnit);
+
+  /* Check if LAL dictionary exists. If not, create a LAL dictionary. */
+  INT4 lalParams_In = 0;
+  if(lalParams == NULL)
+  {
+    lalParams_In = 1;
+    lalParams = XLALCreateDict();
+  }
+
+  if(debug)
+  {
+    printf("\n\n **** Initializing amplitude struct... **** \n\n");
+  }
+
+  /* Allocate and initialize the PhenomX 22 amplitude coefficients struct */
+  IMRPhenomXAmpCoefficients *pAmp22;
+  pAmp22 = XLALMalloc(sizeof(IMRPhenomXAmpCoefficients));
+  status = IMRPhenomXGetAmplitudeCoefficients(pWF,pAmp22);
+  XLAL_CHECK(XLAL_SUCCESS == status, XLAL_EFUNC, "Error: IMRPhenomXGetAmplitudeCoefficients failed.\n");
+
+  if(debug)
+  {
+    printf("\n\n **** Amplitude struct initialized. **** \n\n");
+    printf("\n\n **** Initializing phase struct... **** \n\n");
+  }
+
+  /* Allocate and initialize the PhenomX 22 phase coefficients struct */
+  IMRPhenomXPhaseCoefficients *pPhase22;
+  pPhase22 = XLALMalloc(sizeof(IMRPhenomXPhaseCoefficients));
+  status   = IMRPhenomXGetPhaseCoefficients(pWF,pPhase22);
+  XLAL_CHECK(XLAL_SUCCESS == status, XLAL_EFUNC, "Error: IMRPhenomXGetPhaseCoefficients failed.\n");
+
+  if(debug)
+  {
+    printf("\n\n **** Phase struct initialized. **** \n\n");
+  }
+
+  /*
+      Apply time shifts so peak amplitude is near t ~Â 0.
+  */
+
+  /* Initialize a struct containing useful powers of Mf at fRef */
+  IMRPhenomX_UsefulPowers powers_of_MfRef;
+  status = IMRPhenomX_Initialize_Powers(&powers_of_MfRef,pWF->MfRef);
+  XLAL_CHECK(XLAL_SUCCESS == status, status, "IMRPhenomX_Initialize_Powers failed for MfRef.\n");
+
+  /* Linear time and phase shifts so that model peaks near t ~ 0 */
+  REAL8 lina = 0;
+
+  /* Get phase connection coefficients */
+  IMRPhenomX_Phase_22_ConnectionCoefficients(pWF,pPhase22);
+  double linb=IMRPhenomX_TimeShift_22(pPhase22, pWF);
+
+  /* 1/eta is used to re-scale phase */
+  REAL8 inveta    = (1.0 / pWF->eta);
+
+  /* Calculate phase at reference frequency: phifRef = 2.0*phi0 + LAL_PI_4 + PhenomXPhase(fRef) */
+  pWF->phifRef = -(inveta * IMRPhenomX_Phase_22(pWF->MfRef, &powers_of_MfRef, pPhase22, pWF) + linb*pWF->MfRef + lina) + 2.0*pWF->phi0 + LAL_PI_4;
+
+  /*
+      Here we declare explicit REAL8 variables for main loop in order to avoid numerous
+      pointer calls.
+  */
+  //REAL8 MfRef     = pWF->MfRef;
+  REAL8 Msec      = pWF->M_sec;
+
+  REAL8 C1IM      = pPhase22->C1Int;
+  REAL8 C2IM      = pPhase22->C2Int;
+  REAL8 C1RD      = pPhase22->C1MRD;
+  REAL8 C2RD      = pPhase22->C2MRD;
+
+  REAL8 fPhaseIN  = pPhase22->fPhaseMatchIN;
+  REAL8 fPhaseIM  = pPhase22->fPhaseMatchIM;
+  REAL8 fAmpIN    = pAmp22->fAmpMatchIN;
+  REAL8 fAmpIM    = pAmp22->fAmpRDMin;
+
+  if(debug)
+  {
+    printf("\n\n **** Phase struct initialized. **** \n\n");
+    printf("C1IM     = %.4f\n",C1IM);
+    printf("C2IM     = %.4f\n",C2IM);
+    printf("C1RD     = %.4f\n",C1RD);
+    printf("C2RD     = %.4f\n",C2RD);
+    printf("fIN      = %.4f\n",fPhaseIN);
+    printf("fIM      = %.4f\n",fPhaseIM);
+  }
+
+  REAL8 Amp0      = pWF->amp0 * pWF->ampNorm;
+
+  /* initial_status used to track  */
+  UINT4 initial_status = XLAL_SUCCESS;
+
+  /* Now loop over main driver to generate waveform:  h(f) = A(f) * Exp[I phi(f)] */
+  #pragma omp parallel for
+  for (UINT4 idx = 0; idx < freqs->length; idx++)
+  {
+    double Mf    = Msec * freqs->data[idx];   // Mf is declared locally inside the loop
+    UINT4 jdx    = idx  + offset;             // jdx is declared locally inside the loop
+
+    /* Initialize a struct containing useful powers of Mf */
+    IMRPhenomX_UsefulPowers powers_of_Mf;
+    initial_status     = IMRPhenomX_Initialize_Powers(&powers_of_Mf,Mf);
+    if(initial_status != XLAL_SUCCESS)
+    {
+      status = initial_status;
+      XLALPrintError("IMRPhenomX_Initialize_Powers failed for Mf, initial_status=%d",initial_status);
+    }
+    else
+    {
+      /* Generate amplitude and phase at MfRef */
+      REAL8 amp = 0.0;
+      REAL8 phi = 0.0;
+
+      /* The functions in this routine are inlined to help performance. */
+      /* Construct phase */
+      if(Mf < fPhaseIN)
+      {
+        phi = IMRPhenomX_Inspiral_Phase_22_AnsatzInt(Mf, &powers_of_Mf, pPhase22);
+      }
+      else if(Mf > fPhaseIM)
+      {
+        phi = IMRPhenomX_Ringdown_Phase_22_AnsatzInt(Mf, &powers_of_Mf, pWF, pPhase22) + C1RD + (C2RD * Mf);
+      }
+      else
+      {
+        phi = IMRPhenomX_Intermediate_Phase_22_AnsatzInt(Mf, &powers_of_Mf, pWF, pPhase22) + C1IM + (C2IM * Mf);
+      }
+
+	  /* Scale phase by 1/eta */
+	  phi  *= inveta;
+      phi  += linb*Mf + lina + pWF->phifRef;
+
+	  /* Construct amplitude */
+	  if(Mf < fAmpIN)
+	  {
+		  amp = IMRPhenomX_Inspiral_Amp_22_Ansatz(Mf, &powers_of_Mf, pWF, pAmp22);
+	  }
+	  else if(Mf > fAmpIM)
+	  {
+		  amp = IMRPhenomX_Ringdown_Amp_22_Ansatz(Mf, pWF, pAmp22);
+	  }
+	  else
+	  {
+        amp = IMRPhenomX_Intermediate_Amp_22_Ansatz(Mf, &powers_of_Mf, pWF, pAmp22);
+      }
+
+	  /* Reconstruct waveform: h(f) = A(f) * Exp[I phi(f)] */
+      ((*wfamplitude)->data->data)[jdx] = Amp0 * powers_of_Mf.m_seven_sixths * amp;
+      ((*wfphase)->data->data)[jdx] = phi;
+    }
+  }
+
+  // Free allocated memory
+  LALFree(pAmp22);
+  LALFree(pPhase22);
+  XLALDestroyREAL8Sequence(freqs);
+  if(lalParams_In == 1)
+  {
+    XLALDestroyDict(lalParams);
+  }
+
+  return status;
+}
diff --git a/lalsimulation/lib/LALSimIMRPhenomX.h b/lalsimulation/lib/LALSimIMRPhenomX.h
index 0815561bfc..4cc3beda16 100644
--- a/lalsimulation/lib/LALSimIMRPhenomX.h
+++ b/lalsimulation/lib/LALSimIMRPhenomX.h
@@ -48,6 +48,14 @@ int IMRPhenomXASGenerateFD(
   LALDict *lalParams
 );
 
+int IMRPhenomXASGenerateFDAmpPhs(
+  REAL8FrequencySeries **wfamplitude,
+  REAL8FrequencySeries **wfphase,
+  const REAL8Sequence *freqs,
+  IMRPhenomXWaveformStruct *pWF,
+  LALDict *lalParams
+);
+
 
 int IMRPhenomXCheckForUniformFrequencies(REAL8Sequence *frequencies,REAL8 df);
 
diff --git a/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c b/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
index 5a83110506..ac9968e592 100644
--- a/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
+++ b/lalsimulation/lib/LALSimIMRSEOBNRv4ROM.c
@@ -1616,3 +1616,480 @@ UNUSED static void SEOBNRv4ROM_Init_LALDATA(void)
   XLAL_ERROR_VOID(XLAL_EFAILED, "SEOBNRv4ROM requires HDF5 support which is not enabled\n");
 #endif
 }
+
+
+
+
+
+
+/**Private function to compute the SEOBNRV4ROM amplitude and phase **/
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+UNUSED static int SEOBNRv4ROMCoreAmpPhs(
+  REAL8FrequencySeries **wfamplitude,	/**< Output: Frequency-domain waveform h+ */
+  REAL8FrequencySeries **wfphase,	/**< Output: Frequency-domain waveform hx */
+  double phiRef,			/**< Orbital phase (rad) */
+  double fRef,				/**< Reference frequency */
+  double distance,			/**< Distance of source (m) */
+  double inclination,			/**< Inclination angle of source (rad) */
+  double Mtot_sec,			/**< Total source mass in seconds */
+  double eta,				/**< Symmetric mass ratio */
+  double chi1,				/**< Dimensionless aligned spin on companion 1 */
+  double chi2,				/**< Dimensionless aligned spin on companion 2 */
+  const REAL8Sequence *freqs, /* Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF,			/**< Sampling frequency (Hz).
+   * If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+  int nk_max, // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+);
+
+
+
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi1, chi2).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+static int SEOBNRv4ROMCoreAmpPhs(
+  REAL8FrequencySeries **wfamplitude,	/**< [out] Frequency-domain waveform h+ */
+  REAL8FrequencySeries **wfphase,	/**< [out] Frequency-domain waveform hx */
+  double phiRef, 			/**< orbital reference phase */
+  double fRef,				/**< Reference frequency */
+  double distance,			/**< Distance of source (m) */
+  double inclination,			/**< Inclination of source */
+  double Mtot_sec,			/**< Total mass of source in seconds */
+  double eta,				/**< Symmetric mass ratio */
+  double chi1,				/**< Dimensionless spin aligned spin on companion 1 */
+  double chi2,				/**< Dimensionless aligned spin on companion 2 */
+  const REAL8Sequence *freqs_in, 	/**< Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF,			/**< Sampling frequency (Hz).
+   * If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+  int nk_max, 				/**< truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version /**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+  )
+{
+
+  /* Check output arrays */
+  if(!wfamplitude || !wfphase)
+    XLAL_ERROR(XLAL_EFAULT);
+
+  SEOBNRROMdataDS *romdata=&__lalsim_SEOBNRv4ROMDS_data;
+  if (!SEOBNRv4ROM_IsSetup()) {
+    XLAL_ERROR(XLAL_EFAILED,
+               "Error setting up SEOBNRv4ROM data - check your $LAL_DATA_PATH\n");
+  }
+
+  if(*wfamplitude || *wfphase) {
+    XLALPrintError("(*wfamplitude) and (*wfphase) are supposed to be NULL, but got %p and %p",
+                   (*wfamplitude), (*wfphase));
+    XLAL_ERROR(XLAL_EFAULT);
+  }
+  int retcode=0;
+
+  // 'Nudge' parameter values to allowed boundary values if close by
+  if (eta > 0.25)     nudge(&eta, 0.25, 1e-6);
+  if (eta < 0.01)     nudge(&eta, 0.01, 1e-6);
+
+  if ( chi1 < -1.0 || chi2 < -1.0 || chi1 > 1.0 || chi2 > 1.0) {
+    XLALPrintError("XLAL Error - %s: chi1 or chi2 smaller than -1.0 or larger than 1.0!\n"
+                   "SEOBNRv4ROM is only available for spins in the range -1 <= a/M <= 1.0.\n",
+                   __func__);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  if (eta<0.01 || eta > 0.25) {
+    XLALPrintError("XLAL Error - %s: eta (%f) smaller than 0.01 or unphysical!\n"
+                   "SEOBNRv4ROM is only available for eta in the range 0.01 <= eta <= 0.25.\n",
+                   __func__, eta);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  /* We always need to glue two submodels together for this ROM */
+  SEOBNRROMdataDS_submodel *submodel_hi; // high frequency ROM
+  SEOBNRROMdataDS_submodel *submodel_lo; // low frequency ROM
+  submodel_lo = romdata->sub1;
+
+  /* Select high frequency ROM submodel */
+  if (chi1 < romdata->sub3->chi1_bounds[0] || eta > romdata->sub3->eta_bounds[1]) // only check the two conditions that apply for this ROM; could be more general, but slower
+    submodel_hi = romdata->sub2;
+  else
+    submodel_hi = romdata->sub3;
+
+
+  /* Find frequency bounds */
+  if (!freqs_in) XLAL_ERROR(XLAL_EFAULT);
+  double fLow  = freqs_in->data[0];
+  double fHigh = freqs_in->data[freqs_in->length - 1];
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  /* Convert to geometric units for frequency */
+  // lowest allowed geometric frequency for ROM
+  double Mf_ROM_min = fmax(gsl_vector_get(submodel_lo->gA, 0),
+                           gsl_vector_get(submodel_lo->gPhi,0));
+  // highest allowed geometric frequency for ROM
+  double Mf_ROM_max = fmin(gsl_vector_get(submodel_hi->gA, submodel_hi->nk_amp-1),
+                           gsl_vector_get(submodel_hi->gPhi, submodel_hi->nk_phi-1));
+  double fLow_geom = fLow * Mtot_sec;
+  double fHigh_geom = fHigh * Mtot_sec;
+  double fRef_geom = fRef * Mtot_sec;
+  double deltaF_geom = deltaF * Mtot_sec;
+
+  // Enforce allowed geometric frequency range
+  if (fLow_geom < Mf_ROM_min)
+    XLAL_ERROR(XLAL_EDOM, "Starting frequency Mflow=%g is smaller than lowest frequency in ROM Mf=%g.\n", fLow_geom, Mf_ROM_min);
+  if (fHigh_geom == 0 || fHigh_geom > Mf_ROM_max)
+    fHigh_geom = Mf_ROM_max;
+  else if (fHigh_geom < Mf_ROM_min)
+    XLAL_ERROR(XLAL_EDOM, "End frequency %g is smaller than ROM starting frequency %g!\n", fHigh_geom, Mf_ROM_min);
+  if (fHigh_geom <= fLow_geom)
+    XLAL_ERROR(XLAL_EDOM, "End frequency %g is smaller than (or equal to) starting frequency %g!\n", fHigh_geom, fLow_geom);
+  if (fRef_geom > Mf_ROM_max) {
+    XLALPrintWarning("Reference frequency Mf_ref=%g is greater than maximal frequency in ROM Mf=%g. Starting at maximal frequency in ROM.\n", fRef_geom, Mf_ROM_max);
+    fRef_geom = Mf_ROM_max; // If fref > fhigh we reset fref to default value of cutoff frequency.
+  }
+  if (fRef_geom < Mf_ROM_min) {
+    XLALPrintWarning("Reference frequency Mf_ref=%g is smaller than lowest frequency in ROM Mf=%g. Starting at lowest frequency in ROM.\n", fLow_geom, Mf_ROM_min);
+    fRef_geom = Mf_ROM_min;
+  }
+
+  if (Mtot_sec/LAL_MTSUN_SI > 500.0)
+    XLALPrintWarning("Total mass=%gMsun > 500Msun. SEOBNRv4ROM disagrees with SEOBNRv4 for high total masses.\n", Mtot_sec/LAL_MTSUN_SI);
+
+  /* Internal storage for waveform coefficiencts */
+  SEOBNRROMdataDS_coeff *romdata_coeff_lo=NULL;
+  SEOBNRROMdataDS_coeff *romdata_coeff_hi=NULL;
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff_lo, submodel_lo->nk_amp, submodel_lo->nk_phi);
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff_hi, submodel_hi->nk_amp, submodel_hi->nk_phi);
+  REAL8 amp_pre_lo = 1.0; // unused here
+  REAL8 amp_pre_hi = 1.0;
+
+  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
+  retcode=TP_Spline_interpolation_3d(
+    eta,                          // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
+    submodel_lo->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel_lo->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel_lo->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel_lo->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+    submodel_lo->ncx,             // Number of points in eta  + 2
+    submodel_lo->ncy,             // Number of points in chi1 + 2
+    submodel_lo->ncz,             // Number of points in chi2 + 2
+    gsl_vector_const_ptr(submodel_lo->etavec, 0),          // B-spline knots in eta
+    gsl_vector_const_ptr(submodel_lo->chi1vec, 0),        // B-spline knots in chi1
+    gsl_vector_const_ptr(submodel_lo->chi2vec, 0),        // B-spline knots in chi2
+    romdata_coeff_lo->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff_lo->c_phi       // Output: interpolated projection coefficients for phase
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+    XLAL_ERROR(retcode);
+  }
+
+  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
+  retcode=TP_Spline_interpolation_3d(
+    eta,                          // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                         // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                         // Input: chi2-value for which projection coefficients should be evaluated
+    submodel_hi->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel_hi->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel_hi->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel_hi->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    nk_max,                       // truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1
+    submodel_hi->ncx,             // Number of points in eta  + 2
+    submodel_hi->ncy,             // Number of points in chi1 + 2
+    submodel_hi->ncz,             // Number of points in chi2 + 2
+    gsl_vector_const_ptr(submodel_hi->etavec, 0),         // B-spline knots in eta
+    gsl_vector_const_ptr(submodel_hi->chi1vec, 0),        // B-spline knots in chi1
+    gsl_vector_const_ptr(submodel_hi->chi2vec, 0),        // B-spline knots in chi2
+    romdata_coeff_hi->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff_hi->c_phi       // Output: interpolated projection coefficients for phase
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+    XLAL_ERROR(retcode);
+  }
+
+
+  // Compute function values of amplitude an phase on sparse frequency points by evaluating matrix vector products
+  // amp_pts = B_A^T . c_A
+  // phi_pts = B_phi^T . c_phi
+  gsl_vector* amp_f_lo = gsl_vector_alloc(submodel_lo->nk_amp);
+  gsl_vector* phi_f_lo = gsl_vector_alloc(submodel_lo->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bamp, romdata_coeff_lo->c_amp, 0.0, amp_f_lo);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_lo->Bphi, romdata_coeff_lo->c_phi, 0.0, phi_f_lo);
+
+  gsl_vector* amp_f_hi = gsl_vector_alloc(submodel_hi->nk_amp);
+  gsl_vector* phi_f_hi = gsl_vector_alloc(submodel_hi->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bamp, romdata_coeff_hi->c_amp, 0.0, amp_f_hi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel_hi->Bphi, romdata_coeff_hi->c_phi, 0.0, phi_f_hi);
+
+  const double Mfm = 0.01; // Gluing frequency: the low and high frequency ROMs overlap here; this is used both for amplitude and phase.
+
+  // Glue amplitude
+  gsl_interp_accel *acc_amp;
+  gsl_spline *spline_amp;
+  GlueAmplitude(submodel_lo, submodel_hi, amp_f_lo, amp_f_hi, amp_pre_lo, amp_pre_hi, Mfm,
+    &acc_amp, &spline_amp
+  );
+
+  // Glue phasing in frequency to C^1 smoothness
+  gsl_interp_accel *acc_phi;
+  gsl_spline *spline_phi;
+  GluePhasing(submodel_lo, submodel_hi, phi_f_lo, phi_f_hi, Mfm,
+    &acc_phi, &spline_phi
+  );
+
+  size_t npts = 0;
+  LIGOTimeGPS tC = {0, 0};
+  UINT4 offset = 0; // Index shift between freqs and the frequency series
+  REAL8Sequence *freqs = NULL;
+  REAL8Sequence *amp_tidal = NULL; /* Tidal amplitude series; required only for SEOBNRv4_ROM_NRTidalv2 */
+  if (deltaF > 0)  { // freqs contains uniform frequency grid with spacing deltaF; we start at frequency 0
+    /* Set up output array with size closest power of 2 */
+    npts = NextPow2(fHigh_geom / deltaF_geom) + 1;
+    if (fHigh_geom < fHigh * Mtot_sec) /* Resize waveform if user wants f_max larger than cutoff frequency */
+      npts = NextPow2(fHigh * Mtot_sec / deltaF_geom) + 1;
+
+    XLALGPSAdd(&tC, -1. / deltaF);  /* coalesce at t=0 */
+    *wfamplitude = XLALCreateREAL8FrequencySeries("hptilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+    *wfphase = XLALCreateREAL8FrequencySeries("hctilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+
+    // Recreate freqs using only the lower and upper bounds
+    // Use fLow, fHigh and deltaF rather than geometric frequencies for numerical accuracy
+    double fHigh_temp = fHigh_geom / Mtot_sec;
+    UINT4 iStart = (UINT4) ceil(fLow / deltaF);
+    UINT4 iStop = (UINT4) ceil(fHigh_temp / deltaF);
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    if (!freqs) {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+    for (UINT4 i=iStart; i<iStop; i++)
+      freqs->data[i-iStart] = i*deltaF_geom;
+
+    offset = iStart;
+  } else { // freqs contains frequencies with non-uniform spacing; we start at lowest given frequency
+    npts = freqs_in->length;
+    *wfamplitude = XLALCreateREAL8FrequencySeries("hptilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    *wfamplitude = XLALCreateREAL8FrequencySeries("hctilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    offset = 0;
+
+    freqs = XLALCreateREAL8Sequence(freqs_in->length);
+    if (!freqs) {
+      XLAL_ERROR(XLAL_EFUNC, "Frequency array allocation failed.");
+    }
+    for (UINT4 i=0; i<freqs_in->length; i++)
+      freqs->data[i] = freqs_in->data[i] * Mtot_sec;
+  }
+
+  if (!(*wfamplitude) || !(*wfphase))	{
+      XLALDestroyREAL8Sequence(freqs);
+      gsl_spline_free(spline_amp);
+      gsl_spline_free(spline_phi);
+      gsl_interp_accel_free(acc_amp);
+      gsl_interp_accel_free(acc_phi);
+      SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+      SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+      XLAL_ERROR(XLAL_EFUNC);
+  }
+  memset((*wfamplitude)->data->data, 0, npts * sizeof(REAL8));
+  memset((*wfphase)->data->data, 0, npts * sizeof(REAL8));
+
+  XLALUnitMultiply(&(*wfamplitude)->sampleUnits, &(*wfamplitude)->sampleUnits, &lalSecondUnit);
+  XLALUnitMultiply(&(*wfphase)->sampleUnits, &(*wfphase)->sampleUnits, &lalSecondUnit);
+
+  REAL8 *pdata=(*wfamplitude)->data->data;
+  REAL8 *cdata=(*wfphase)->data->data;
+
+  REAL8 cosi = cos(inclination);
+  REAL8 pcoef = 0.5*(1.0 + cosi*cosi);
+  //REAL8 ccoef = cosi;
+
+  REAL8 s = 0.5; // Scale polarization amplitude so that strain agrees with FFT of SEOBNRv4
+  double Mtot = Mtot_sec / LAL_MTSUN_SI;
+  double amp0 = Mtot * Mtot_sec * LAL_MRSUN_SI / (distance); // Correct overall amplitude to undo mass-dependent scaling used in ROM
+
+  // Evaluate reference phase for setting phiRef correctly
+  double phase_change = gsl_spline_eval(spline_phi, fRef_geom, acc_phi) - 2*phiRef;
+  
+  int ret = XLAL_SUCCESS;
+  // Assemble waveform from aplitude and phase
+  if (NRTidal_version == NRTidalv2_V) {
+    /* get component masses (in solar masses) from mtotal and eta! */
+    const REAL8 factor = sqrt(1. - 4.*eta);
+    const REAL8 m1 = 0.5*Mtot*(1.+ factor);
+    const REAL8 m2 = 0.5*Mtot*(1.- factor);
+    /* Generate the tidal amplitude (Eq. 24 of arxiv: 1905.06011) to add to BBH baseline; only for NRTidalv2 */
+    amp_tidal = XLALCreateREAL8Sequence(freqs->length);
+    const REAL8 l1 = XLALSimInspiralWaveformParamsLookupTidalLambda1(LALparams);
+    const REAL8 l2 = XLALSimInspiralWaveformParamsLookupTidalLambda2(LALparams);
+
+    ret = XLALSimNRTunedTidesFDTidalAmplitudeFrequencySeries(amp_tidal, freqs, m1, m2, l1, l2);
+    XLAL_CHECK(XLAL_SUCCESS == ret, ret, "Failed to generate tidal amplitude series to construct SEOBNRv4_ROM_NRTidalv2 waveform.");
+    /* Generated tidal amplitude corrections */
+    for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+      double f = freqs->data[i];
+      double ampT = amp_tidal->data[i];
+
+      if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+      int j = i + offset; // shift index for frequency series if needed
+      double A = gsl_spline_eval(spline_amp, f, acc_amp);
+      double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
+      //COMPLEX16 htilde = s*amp0*(A+ampT) * (cos(phase) + I*sin(phase)); //cexp(I*phase);
+      pdata[j] =  pcoef *  s*amp0*(A+ampT);
+      cdata[j] = phase;
+    }
+  } else {
+      for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+        double f = freqs->data[i];
+        if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+        int j = i + offset; // shift index for frequency series if needed
+        double A = gsl_spline_eval(spline_amp, f, acc_amp);
+        double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
+        //COMPLEX16 htilde = s*amp0*A * (cos(phase) + I*sin(phase));//cexp(I*phase);
+
+        pdata[j] =  pcoef * s*amp0*A;
+        cdata[j] = phase;
+      }
+   }
+
+  /* Correct phasing so we coalesce at t=0 (with the definition of the epoch=-1/deltaF above) */
+
+  // Get SEOBNRv4 ringdown frequency for 22 mode
+  double Mf_final = SEOBNRROM_Ringdown_Mf_From_Mtot_Eta(Mtot_sec, eta, chi1,
+                                                        chi2, SEOBNRv4);
+
+  // prevent gsl interpolation errors
+  // The ringdown frequency Mf_final is only used to evaluate the spline_phi
+  // derivative below and spline_phi has domain [Mf_ROM_min, Mf_ROM_max].
+  // Mf_final should always be inside this interval, but we'll check anyway.
+  if (Mf_final > Mf_ROM_max)
+    Mf_final = Mf_ROM_max;
+  if (Mf_final < Mf_ROM_min) {
+    XLALDestroyREAL8Sequence(freqs);
+    gsl_spline_free(spline_amp);
+    gsl_spline_free(spline_phi);
+    gsl_interp_accel_free(acc_amp);
+    gsl_interp_accel_free(acc_phi);
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+    XLAL_ERROR(XLAL_EDOM, "f_ringdown < f_min");
+  }
+
+  // Time correction is t(f_final) = 1/(2pi) dphi/df (f_final)
+  // We compute the dimensionless time correction t/M since we use geometric units.
+  REAL8 t_corr = gsl_spline_eval_deriv(spline_phi, Mf_final, acc_phi) / (2*LAL_PI);
+
+  // Now correct phase
+  for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+    double f = freqs->data[i] - fRef_geom;
+    int j = i + offset; // shift index for frequency series if needed
+    double phase_factor = -2*LAL_PI * f * t_corr;
+    //COMPLEX16 t_factor = (cos(phase_factor) + I*sin(phase_factor));//cexp(I*phase_factor);
+    //pdata[j] *= t_factor;
+    cdata[j] += phase_factor;
+  }
+
+  XLALDestroyREAL8Sequence(freqs);
+  XLALDestroyREAL8Sequence(amp_tidal);
+
+  gsl_spline_free(spline_amp);
+  gsl_spline_free(spline_phi);
+  gsl_interp_accel_free(acc_amp);
+  gsl_interp_accel_free(acc_phi);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_lo);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff_hi);
+
+  return(XLAL_SUCCESS);
+}
+
+
+
+/**
+ * Compute waveform in LAL format for the SEOBNRv4_ROM model.
+ *
+ * Returns the plus and cross polarizations as a complex frequency series with
+ * equal spacing deltaF and contains zeros from zero frequency to the starting
+ * frequency fLow and zeros beyond the cutoff frequency in the ringdown.
+ */
+int XLALSimIMRSEOBNRv4ROMAmpPhs(
+  struct tagREAL8FrequencySeries **wfamplitude, /**< Output: Frequency-domain waveform h+ */
+  struct tagREAL8FrequencySeries **wfphase, /**< Output: Frequency-domain waveform hx */
+  REAL8 phiRef,                                 /**< Phase at reference time */
+  REAL8 deltaF,                                 /**< Sampling frequency (Hz) */
+  REAL8 fLow,                                   /**< Starting GW frequency (Hz) */
+  REAL8 fHigh,                                  /**< End frequency; 0 defaults to Mf=0.14 */
+  REAL8 fRef,                                   /**< Reference frequency (Hz); 0 defaults to fLow */
+  REAL8 distance,                               /**< Distance of source (m) */
+  REAL8 inclination,                            /**< Inclination of source (rad) */
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2,                                   /**< Dimensionless aligned component spin 2 */
+  INT4 nk_max,                                  /**< Truncate interpolants at SVD mode nk_max; don't truncate if nk_max == -1 */
+  LALDict *LALparams,                          /**< LAL dictionary containing accessory parameters */
+  NRTidal_version_type NRTidal_version 		/**< NRTidal version; either NRTidal_V or NRTidalv2_V or NoNRT_V in case of BBH baseline */
+)
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  /* Get masses in terms of solar mass */
+  double mass1 = m1SI / LAL_MSUN_SI;
+  double mass2 = m2SI / LAL_MSUN_SI;
+  double Mtot = mass1+mass2;
+  double eta = mass1 * mass2 / (Mtot*Mtot);    /* Symmetric mass-ratio */
+  double Mtot_sec = Mtot * LAL_MTSUN_SI;       /* Total mass in seconds */
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  // Load ROM data if not loaded already
+#ifdef LAL_PTHREAD_LOCK
+  (void) pthread_once(&SEOBNRv4ROM_is_initialized, SEOBNRv4ROM_Init_LALDATA);
+#else
+  SEOBNRv4ROM_Init_LALDATA();
+#endif
+
+  // Use fLow, fHigh, deltaF to compute freqs sequence
+  // Instead of building a full sequency we only transfer the boundaries and let
+  // the internal core function do the rest (and properly take care of corner cases).
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = fLow;
+  freqs->data[1] = fHigh;
+
+  int retcode = SEOBNRv4ROMCoreAmpPhs(wfamplitude, wfphase, phiRef, fRef, distance,
+                                inclination, Mtot_sec, eta, chi1, chi2, freqs,
+                                deltaF, nk_max, LALparams, NRTidal_version);
+
+  XLALDestroyREAL8Sequence(freqs);
+
+  return(retcode);
+}
+
diff --git a/lalsimulation/lib/LALSimInspiral.h b/lalsimulation/lib/LALSimInspiral.h
index b6d3acc555..1cbee07804 100644
--- a/lalsimulation/lib/LALSimInspiral.h
+++ b/lalsimulation/lib/LALSimInspiral.h
@@ -708,6 +708,12 @@ int XLALSimInspiralTaylorF2Core(COMPLEX16FrequencySeries **htilde, const REAL8Se
 
 int XLALSimInspiralTaylorF2(COMPLEX16FrequencySeries **htilde, const REAL8 phi_ref, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 S1z, const REAL8 S2z, const REAL8 fStart, const REAL8 fEnd, const REAL8 f_ref, const REAL8 r, LALDict *LALpars);
 
+
+int XLALSimInspiralTaylorF2CoreAmpPhs(REAL8FrequencySeries **wfamplitude, REAL8FrequencySeries **wfphase, const REAL8Sequence *freqs, const REAL8 phi_ref, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 f_ref, const REAL8 shft, const REAL8 r, LALDict *LALparams, PNPhasingSeries *pfaP);
+
+int XLALSimInspiralTaylorF2AmpPhs(REAL8FrequencySeries **wfamplitude, REAL8FrequencySeries **wfphase, const REAL8 phi_ref, const REAL8 deltaF, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 S1z, const REAL8 S2z, const REAL8 fStart, const REAL8 fEnd, const REAL8 f_ref, const REAL8 r, LALDict *LALpars);
+
+
 /* TaylorF2Ecc functions */
 /* in module LALSimInspiralTaylorF2Ecc.c */
 int XLALSimInspiralTaylorF2CoreEcc(COMPLEX16FrequencySeries **htilde, const REAL8Sequence *freqs, const REAL8 phi_ref, const REAL8 m1_SI, const REAL8 m2_SI, const REAL8 f_ref, const REAL8 shft, const REAL8 r, const REAL8 eccentricity, LALDict *LALparams, PNPhasingSeries *pfaP);
diff --git a/lalsimulation/lib/LALSimInspiralTaylorF2.c b/lalsimulation/lib/LALSimInspiralTaylorF2.c
index 45facd5cde..509f8d0047 100644
--- a/lalsimulation/lib/LALSimInspiralTaylorF2.c
+++ b/lalsimulation/lib/LALSimInspiralTaylorF2.c
@@ -598,5 +598,522 @@ int XLALSimInspiralTaylorF2(
 }
 #include "LALSimInspiralTaylorF2Ecc.c"
 
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/********* Soumen's modification **********/
+
+
+
+
+
+
+int XLALSimInspiralTaylorF2CoreAmpPhs(
+        REAL8FrequencySeries **wfamplitude_out, /**< FD waveform */
+        REAL8FrequencySeries **wfphase_out, /**< FD waveform */
+	const REAL8Sequence *freqs,            /**< frequency points at which to evaluate the waveform (Hz) */
+        const REAL8 phi_ref,                   /**< reference orbital phase (rad) */
+        const REAL8 m1_SI,                     /**< mass of companion 1 (kg) */
+        const REAL8 m2_SI,                     /**< mass of companion 2 (kg) */
+        const REAL8 f_ref,                     /**< Reference GW frequency (Hz) - if 0 reference point is coalescence */
+	const REAL8 shft,		       /**< time shift to be applied to frequency-domain phase (sec)*/
+        const REAL8 r,                         /**< distance of source (m) */
+        LALDict *p, /**< Linked list containing the extra testing GR parameters >*/
+        PNPhasingSeries *pfaP /**< Phasing coefficients >**/
+        )
+{
+
+    if (!wfamplitude_out) XLAL_ERROR(XLAL_EFAULT);
+    if (!wfphase_out) XLAL_ERROR(XLAL_EFAULT);
+    if (!freqs) XLAL_ERROR(XLAL_EFAULT);
+    /* external: SI; internal: solar masses */
+    const REAL8 m1 = m1_SI / LAL_MSUN_SI;
+    const REAL8 m2 = m2_SI / LAL_MSUN_SI;
+    const REAL8 m = m1 + m2;
+    const REAL8 m_sec = m * LAL_MTSUN_SI;  /* total mass in seconds */
+    const REAL8 eta = m1 * m2 / (m * m);
+    const REAL8 piM = LAL_PI * m_sec;
+    REAL8 amp0;
+    size_t i;
+    REAL8 *dataA = NULL;
+    REAL8 *dataP = NULL;
+    LIGOTimeGPS tC = {0, 0};
+    INT4 iStart = 0;
+
+    REAL8FrequencySeries *wfamplitude = NULL;
+
+    if (*wfamplitude_out) { //case when htilde_out has been allocated in XLALSimInspiralTaylorF2
+	    wfamplitude = *wfamplitude_out;
+	    iStart = wfamplitude->data->length - freqs->length; //index shift to fill pre-allocated data
+	    if(iStart < 0) XLAL_ERROR(XLAL_EFAULT);
+    }
+    else { //otherwise allocate memory here
+	    wfamplitude = XLALCreateREAL8FrequencySeries("amplitude: FD waveform", &tC, freqs->data[0], 0., &lalStrainUnit, freqs->length);
+	    if (!wfamplitude) XLAL_ERROR(XLAL_EFUNC);
+	    XLALUnitMultiply(&wfamplitude->sampleUnits, &wfamplitude->sampleUnits, &lalSecondUnit);
+    }
+    
+    REAL8FrequencySeries *wfphase = NULL;
+
+    if (*wfphase_out) { //case when htilde_out has been allocated in XLALSimInspiralTaylorF2
+	    wfphase = *wfphase_out;
+	    iStart = wfphase->data->length - freqs->length; //index shift to fill pre-allocated data
+	    if(iStart < 0) XLAL_ERROR(XLAL_EFAULT);
+    }
+    else { //otherwise allocate memory here
+	    wfphase = XLALCreateREAL8FrequencySeries("phase: FD waveform", &tC, freqs->data[0], 0., &lalStrainUnit, freqs->length);
+	    if (!wfphase) XLAL_ERROR(XLAL_EFUNC);
+	    XLALUnitMultiply(&wfphase->sampleUnits, &wfphase->sampleUnits, &lalSecondUnit);
+    }
+
+    
+    PNPhasingSeries pfa = *pfaP;
+
+    REAL8 pfaN = 0.; REAL8 pfa1 = 0.;
+    REAL8 pfa2 = 0.; REAL8 pfa3 = 0.; REAL8 pfa4 = 0.;
+    REAL8 pfa5 = 0.; REAL8 pfl5 = 0.;
+    REAL8 pfa6 = 0.; REAL8 pfl6 = 0.;
+    REAL8 pfa7 = 0.;
+
+    INT4 phaseO=XLALSimInspiralWaveformParamsLookupPNPhaseOrder(p);
+    switch (phaseO)
+    {
+        case -1:
+        case 7:
+            pfa7 = pfa.v[7];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 6:
+            pfa6 = pfa.v[6];
+            pfl6 = pfa.vlogv[6];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 5:
+            pfa5 = pfa.v[5];
+            pfl5 = pfa.vlogv[5];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 4:
+            pfa4 = pfa.v[4];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 3:
+            pfa3 = pfa.v[3];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 2:
+            pfa2 = pfa.v[2];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 1:
+            pfa1 = pfa.v[1];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case 0:
+            pfaN = pfa.v[0];
+            break;
+        default:
+            XLAL_ERROR(XLAL_ETYPE, "Invalid phase PN order %d", phaseO);
+    }
+
+    /* Validate expansion order arguments.
+     * This must be done here instead of in the OpenMP parallel loop
+     * because when OpenMP parallelization is turned on, early exits
+     * from loops (via return or break statements) are not permitted.
+     */
+
+    /* Validate amplitude PN order. */
+    INT4 amplitudeO=XLALSimInspiralWaveformParamsLookupPNAmplitudeOrder(p);
+    switch (amplitudeO)
+    {
+        case -1:
+        case 7:
+        case 6:
+        case 5:
+        case 4:
+        case 3:
+        case 2:
+        case 0:
+            break;
+        default:
+            XLAL_ERROR(XLAL_ETYPE, "Invalid amplitude PN order %d", amplitudeO);
+    }
+
+    /* Generate tidal terms separately.
+     * Enums specifying tidal order are in LALSimInspiralWaveformFlags.h
+     */
+    REAL8 pft10 = 0.;
+    REAL8 pft12 = 0.;
+    REAL8 pft13 = 0.;
+    REAL8 pft14 = 0.;
+    REAL8 pft15 = 0.;
+    switch( XLALSimInspiralWaveformParamsLookupPNTidalOrder(p) )
+    {
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_75PN:
+            pft15 = pfa.v[15];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_DEFAULT:
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_7PN:
+            pft14 = pfa.v[14];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_65PN:
+            pft13 = pfa.v[13];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_6PN:
+	    pft12 = pfa.v[12];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_5PN:
+            pft10 = pfa.v[10];
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+            __attribute__ ((fallthrough));
+#endif
+        case LAL_SIM_INSPIRAL_TIDAL_ORDER_0PN:
+            break;
+        default:
+	    XLAL_ERROR(XLAL_EINVAL, "Invalid tidal PN order %d", XLALSimInspiralWaveformParamsLookupPNTidalOrder(p) );
+    }
+
+    /* The flux and energy coefficients below are used to compute SPA amplitude corrections */
+
+    /* flux coefficients */
+    const REAL8 FTaN = XLALSimInspiralPNFlux_0PNCoeff(eta);
+    const REAL8 FTa2 = XLALSimInspiralPNFlux_2PNCoeff(eta);
+    const REAL8 FTa3 = XLALSimInspiralPNFlux_3PNCoeff(eta);
+    const REAL8 FTa4 = XLALSimInspiralPNFlux_4PNCoeff(eta);
+    const REAL8 FTa5 = XLALSimInspiralPNFlux_5PNCoeff(eta);
+    const REAL8 FTl6 = XLALSimInspiralPNFlux_6PNLogCoeff(eta);
+    const REAL8 FTa6 = XLALSimInspiralPNFlux_6PNCoeff(eta);
+    const REAL8 FTa7 = XLALSimInspiralPNFlux_7PNCoeff(eta);
+
+    /* energy coefficients */
+    const REAL8 dETaN = 2. * XLALSimInspiralPNEnergy_0PNCoeff(eta);
+    const REAL8 dETa1 = 2. * XLALSimInspiralPNEnergy_2PNCoeff(eta);
+    const REAL8 dETa2 = 3. * XLALSimInspiralPNEnergy_4PNCoeff(eta);
+    const REAL8 dETa3 = 4. * XLALSimInspiralPNEnergy_6PNCoeff(eta);
+
+
+    /* Perform some initial checks */
+    if (m1_SI <= 0) XLAL_ERROR(XLAL_EDOM);
+    if (m2_SI <= 0) XLAL_ERROR(XLAL_EDOM);
+    if (f_ref < 0) XLAL_ERROR(XLAL_EDOM);
+    if (r <= 0) XLAL_ERROR(XLAL_EDOM);
+
+    /* extrinsic parameters */
+    amp0 = -4. * m1 * m2 / r * LAL_MRSUN_SI * LAL_MTSUN_SI * sqrt(LAL_PI/12.L);
+
+    dataA = wfamplitude->data->data;
+    dataP = wfphase->data->data;
+
+    /* Compute the SPA phase at the reference point
+     * N.B. f_ref == 0 means we define the reference time/phase at "coalescence"
+     * when the frequency approaches infinity. In that case,
+     * the integrals Eq. 3.15 of arXiv:0907.0700 vanish when evaluated at
+     * f_ref == infinity. If f_ref is finite, we must compute the SPA phase
+     * evaluated at f_ref, store it as ref_phasing and subtract it off.
+     */
+    REAL8 ref_phasing = 0.;
+    if( f_ref != 0. ) {
+        const REAL8 vref = cbrt(piM*f_ref);
+        const REAL8 logvref = log(vref);
+        const REAL8 v2ref = vref * vref;
+        const REAL8 v3ref = vref * v2ref;
+        const REAL8 v4ref = vref * v3ref;
+        const REAL8 v5ref = vref * v4ref;
+        const REAL8 v6ref = vref * v5ref;
+        const REAL8 v7ref = vref * v6ref;
+        const REAL8 v8ref = vref * v7ref;
+        const REAL8 v9ref = vref * v8ref;
+        const REAL8 v10ref = vref * v9ref;
+        const REAL8 v12ref = v2ref * v10ref;
+        const REAL8 v13ref = vref * v12ref;
+        const REAL8 v14ref = vref * v13ref;
+        const REAL8 v15ref = vref * v14ref;
+        ref_phasing += pfa7 * v7ref;
+        ref_phasing += (pfa6 + pfl6 * logvref) * v6ref;
+        ref_phasing += (pfa5 + pfl5 * logvref) * v5ref;
+        ref_phasing += pfa4 * v4ref;
+        ref_phasing += pfa3 * v3ref;
+        ref_phasing += pfa2 * v2ref;
+        ref_phasing += pfa1 * vref;
+        ref_phasing += pfaN;
+
+        /* Tidal terms in reference phasing */
+        ref_phasing += pft15 * v15ref;
+        ref_phasing += pft14 * v14ref;
+        ref_phasing += pft13 * v13ref;
+        ref_phasing += pft12 * v12ref;
+        ref_phasing += pft10 * v10ref;
+
+        ref_phasing /= v5ref;
+    } /* End of if(f_ref != 0) block */
+
+    #pragma omp parallel for
+    for (i = 0; i < freqs->length; i++) {
+        const REAL8 f = freqs->data[i];
+        const REAL8 v = cbrt(piM*f);
+        const REAL8 logv = log(v);
+        const REAL8 v2 = v * v;
+        const REAL8 v3 = v * v2;
+        const REAL8 v4 = v * v3;
+        const REAL8 v5 = v * v4;
+        const REAL8 v6 = v * v5;
+        const REAL8 v7 = v * v6;
+        const REAL8 v8 = v * v7;
+        const REAL8 v9 = v * v8;
+        const REAL8 v10 = v * v9;
+        const REAL8 v12 = v2 * v10;
+        const REAL8 v13 = v * v12;
+        const REAL8 v14 = v * v13;
+        const REAL8 v15 = v * v14;
+        REAL8 phasing = 0.;
+        REAL8 dEnergy = 0.;
+        REAL8 flux = 0.;
+        REAL8 amp;
+
+        phasing += pfa7 * v7;
+        phasing += (pfa6 + pfl6 * logv) * v6;
+        phasing += (pfa5 + pfl5 * logv) * v5;
+        phasing += pfa4 * v4;
+        phasing += pfa3 * v3;
+        phasing += pfa2 * v2;
+        phasing += pfa1 * v;
+        phasing += pfaN;
+
+        /* Tidal terms in phasing */
+        phasing += pft15 * v15;
+        phasing += pft14 * v14;
+        phasing += pft13 * v13;
+        phasing += pft12 * v12;
+        phasing += pft10 * v10;
+
+    /* WARNING! Amplitude orders beyond 0 have NOT been reviewed!
+     * Use at your own risk. The default is to turn them off.
+     * These do not currently include spin corrections.
+     * Note that these are not higher PN corrections to the amplitude.
+     * They are the corrections to the leading-order amplitude arising
+     * from the stationary phase approximation. See for instance
+     * Eq 6.9 of arXiv:0810.5336
+     */
+	switch (amplitudeO)
+        {
+            case 7:
+                flux += FTa7 * v7;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case 6:
+                flux += (FTa6 + FTl6*logv) * v6;
+                dEnergy += dETa3 * v6;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case 5:
+                flux += FTa5 * v5;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case 4:
+                flux += FTa4 * v4;
+                dEnergy += dETa2 * v4;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case 3:
+                flux += FTa3 * v3;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case 2:
+                flux += FTa2 * v2;
+                dEnergy += dETa1 * v2;
+#if __GNUC__ >= 7 && !defined __INTEL_COMPILER
+                __attribute__ ((fallthrough));
+#endif
+            case -1: /* Default to no SPA amplitude corrections */
+            case 0:
+                flux += 1.;
+                dEnergy += 1.;
+        }
+
+        phasing /= v5;
+        flux *= FTaN * v10;
+        dEnergy *= dETaN * v;
+        // Note the factor of 2 b/c phi_ref is orbital phase
+        phasing += shft * f - 2.*phi_ref - ref_phasing;
+        amp = amp0 * sqrt(-dEnergy/flux) * v;
+        dataA[i+iStart] = amp;
+        dataP[i+iStart] = phasing - LAL_PI_4;
+    }
+
+    *wfamplitude_out = wfamplitude;
+    *wfphase_out = wfphase;
+    return XLAL_SUCCESS;
+}
+
+
+
+
+
+/**
+ * Computes the stationary phase approximation to the Fourier transform of
+ * a chirp waveform. The amplitude is given by expanding \f$1/\sqrt{\dot{F}}\f$.
+ * If the PN order is set to -1, then the highest implemented order is used.
+ *
+ * @note f_ref is the GW frequency at which phi_ref is defined. The most common
+ * choice in the literature is to choose the reference point as "coalescence",
+ * when the frequency becomes infinite. This is the behavior of the code when
+ * f_ref==0. If f_ref > 0, phi_ref sets the orbital phase at that GW frequency.
+ *
+ * See arXiv:0810.5336 and arXiv:astro-ph/0504538 for spin corrections
+ * to the phasing.
+ * See arXiv:1303.7412 for spin-orbit phasing corrections at 3 and 3.5PN order
+ *
+ * The spin and tidal order enums are defined in LALSimInspiralWaveformFlags.h
+ */
+int XLALSimInspiralTaylorF2AmpPhs(
+        REAL8FrequencySeries **wfamplitude_out, /**< FD waveform */
+        REAL8FrequencySeries **wfphase_out, /**< FD waveform */
+        const REAL8 phi_ref,                   /**< reference orbital phase (rad) */
+        const REAL8 deltaF,                    /**< frequency resolution */
+        const REAL8 m1_SI,                     /**< mass of companion 1 (kg) */
+        const REAL8 m2_SI,                     /**< mass of companion 2 (kg) */
+        const REAL8 S1z,                       /**<  z component of the spin of companion 1 */
+        const REAL8 S2z,                       /**<  z component of the spin of companion 2  */
+        const REAL8 fStart,                    /**< start GW frequency (Hz) */
+        const REAL8 fEnd,                      /**< highest GW frequency (Hz) of waveform generation - if 0, end at Schwarzschild ISCO */
+        const REAL8 f_ref,                     /**< Reference GW frequency (Hz) - if 0 reference point is coalescence */
+        const REAL8 r,                         /**< distance of source (m) */
+        LALDict *p /**< Linked list containing the extra testing GR parameters >**/
+        )
+{
+    /* external: SI; internal: solar masses */
+    const REAL8 m1 = m1_SI / LAL_MSUN_SI;
+    const REAL8 m2 = m2_SI / LAL_MSUN_SI;
+    const REAL8 m = m1 + m2;
+    const REAL8 m_sec = m * LAL_MTSUN_SI;  /* total mass in seconds */
+    // const REAL8 eta = m1 * m2 / (m * m);
+    const REAL8 piM = LAL_PI * m_sec;
+    const REAL8 vISCO = 1. / sqrt(6.);
+    const REAL8 fISCO = vISCO * vISCO * vISCO / piM;
+    //const REAL8 m1OverM = m1 / m;
+    // const REAL8 m2OverM = m2 / m;
+    REAL8 shft, f_max;
+    size_t i, n;
+    INT4 iStart;
+    REAL8Sequence *freqs = NULL;
+    LIGOTimeGPS tC = {0, 0};
+    int ret;
+    int retcode;
+    REAL8 fCONT;
+    INT4 tideO = XLALSimInspiralWaveformParamsLookupPNTidalOrder(p);
+    REAL8 lambda1 = XLALSimInspiralWaveformParamsLookupTidalLambda1(p);
+    REAL8 lambda2 = XLALSimInspiralWaveformParamsLookupTidalLambda2(p);
+    retcode = XLALSimInspiralSetQuadMonParamsFromLambdas(p);
+    XLAL_CHECK(retcode == XLAL_SUCCESS, XLAL_EFUNC, "Failed to set quadparams from Universal relation.\n");
+
+    REAL8FrequencySeries *wfamplitude = NULL;
+    REAL8FrequencySeries *wfphase = NULL;
+
+    /* Perform some initial checks */
+    if (!wfamplitude_out) XLAL_ERROR(XLAL_EFAULT);
+    if (*wfamplitude_out) XLAL_ERROR(XLAL_EFAULT);
+    if (!wfphase_out) XLAL_ERROR(XLAL_EFAULT);
+    if (*wfphase_out) XLAL_ERROR(XLAL_EFAULT);
+    if (m1_SI <= 0) XLAL_ERROR(XLAL_EDOM);
+    if (m2_SI <= 0) XLAL_ERROR(XLAL_EDOM);
+    if (fStart <= 0) XLAL_ERROR(XLAL_EDOM);
+    if (f_ref < 0) XLAL_ERROR(XLAL_EDOM);
+    if (r <= 0) XLAL_ERROR(XLAL_EDOM);
+
+    /* allocate htilde */
+    if (( fEnd == 0. ) && ( tideO == 0 )) // End at ISCO
+        f_max = fISCO;
+    else if (( fEnd == 0. ) && ( tideO != 0 )) { // End at the minimum of the contact and ISCO frequencies only when tides are enabled
+        fCONT = XLALSimInspiralContactFrequency(m1, lambda1, m2, lambda2); /* Contact frequency of two compact objects */
+        f_max = (fCONT > fISCO) ? fISCO : fCONT;
+    }
+    else // End at user-specified freq.
+        f_max = fEnd;
+    if (f_max <= fStart) XLAL_ERROR(XLAL_EDOM);
+
+    n = (size_t) (f_max / deltaF + 1);
+    XLALGPSAdd(&tC, -1 / deltaF);  /* coalesce at t=0 */
+    wfamplitude = XLALCreateREAL8FrequencySeries("amplitude: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, n);
+    if (!wfamplitude) XLAL_ERROR(XLAL_EFUNC);
+    memset(wfamplitude->data->data, 0, n * sizeof(REAL8));
+    XLALUnitMultiply(&wfamplitude->sampleUnits, &wfamplitude->sampleUnits, &lalSecondUnit);
+    
+    wfphase = XLALCreateREAL8FrequencySeries("phase: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, n);
+    if (!wfphase) XLAL_ERROR(XLAL_EFUNC);
+    memset(wfphase->data->data, 0, n * sizeof(REAL8));
+    XLALUnitMultiply(&wfphase->sampleUnits, &wfphase->sampleUnits, &lalSecondUnit);
+
+    /* Fill with non-zero vals from fStart to f_max */
+    iStart = (INT4) ceil(fStart / deltaF);
+
+    /* Sequence of frequencies where waveform model is to be evaluated */
+    freqs = XLALCreateREAL8Sequence(n - iStart);
+
+    /* extrinsic parameters */
+    shft = LAL_TWOPI * (tC.gpsSeconds + 1e-9 * tC.gpsNanoSeconds);
+
+    #pragma omp parallel for
+    for (i = iStart; i < n; i++) {
+        freqs->data[i-iStart] = i * deltaF;
+    }
+
+    /* phasing coefficients */
+    PNPhasingSeries pfa;
+    XLALSimInspiralPNPhasing_F2(&pfa, m1, m2, S1z, S2z, S1z*S1z, S2z*S2z, S1z*S2z, p);
+
+    ret = XLALSimInspiralTaylorF2CoreAmpPhs(&wfamplitude, &wfphase, freqs, phi_ref, m1_SI, m2_SI,
+                                      f_ref, shft, r, p, &pfa);
+
+    XLALDestroyREAL8Sequence(freqs);
+
+    *wfamplitude_out = wfamplitude;
+    *wfphase_out = wfphase;
+
+    return ret;
+}
+
+
+
+
+
+
+
+
+
+
 /** @} */
 /** @} */
